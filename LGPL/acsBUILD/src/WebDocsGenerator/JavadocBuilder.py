#! /usr/bin/env python
#*******************************************************************************
# ALMA - Atacama Large Millimiter Array
# Copyright (c) European Southern Observatory, 2016 
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
#
#
# who       when      what
# --------  --------  ----------------------------------------------
# acaproni  2016-05-24  created
#
from optparse import OptionParser
from subprocess import call
from exceptions import IOError
import os
import sys
import datetime


"""
This python script generates documentation for ACS java sources
by delegating to AcsJavadocBuilder class that in turn runs
javadoc. 

The script takes the following parameters:
   * src folder:  the folder containing java sources (usually ACS as checked out from the repository)
   * dest folder: the folder where javadoc put the HTMLs
"""


class AcsJavadocBuilder(object):
    """
    Objects from this class generates the javadoc documentation of ACS sources
    """
    
    def __init__(self,srcFolder,dstFolder,includeTestFolder=False,outFile=sys.stdout):
        """ 
        Constructor
        @param srcFolder: the folder with java sources to generate their documentation
        @param dstFolder: destination folder for javadocs  
        @param includeTestFolder: True if the class must generate documentation for the java
                sources in test folders (defaults to False)
        @param outFile: the file where the output generated by calling javadoc must be sent
        """
        self.checkFolders(srcFolder,dstFolder)
        self.srcFolder=srcFolder
        self.dstFolder=dstFolder
        self.includeTestFolder=includeTestFolder
        self.outFile=outFile
        assert self.outFile is not None
    
        
    def checkFolders(self,src,dst):
        """
        Check if the source and dest folders are valid and if it is not the case,
        throws an exception
        @param srcr: the folder with java sources to check
        @param dst: destination folder to check
        """
        # Check if src folder exists
        if not os.path.exists(src):
            raise IOError("The source folder", src,"does not exist")
        elif not os.path.isdir(src):
            raise IOError("The source folder", src,"is not a directory")
            
        # Check if the destination folder exists
        if not os.path.exists(dst):
            raise IOError("The destination folder", dst,"does not exist")
        elif not os.path.isdir(dst):
            raise IOError("The destination folder", dst,"is not a directory")
            
    def buildJavadocs(self):
        """
        Build the javadocs by reading java sources from the source folder, including
        those in test is needed
        Javadocs will be written in the destination folder.
        
        Generation of jaavadocs is ddelegatred to Oracle' javadoc executable
        
        @return: the code returned by calling javadoc
        """
        # Look for src (and if it is the case test) folders containing java sources
        folders = self.getSrcPaths(self.srcFolder, self.includeTestFolder)
        
        roots = self.getJavaPackagesRoot(folders)
        
        # Run javadoc
        cmd=self.buildJavadocCmd(self.dstFolder,folders,roots)
        
        return call(cmd,stdout=self.outFile,stderr=self.outFile)
        
    def containsJavaSources(self,folder):
        '''
        @param folder: the folder (src or test) to check if contains java sources
        @return: True if the passed folder contains java sources
        ''' 
        for root, subdirs, files in os.walk(folder):
            for file in files:
                if file.endswith(".java"):
                    return True
        return False

    def getSrcPaths(self,sourceFolder, includeTestFolder):
        """
        Scan the source folder and return a list of source folders
        containg java files.
        Java source can be contained into src or test (the latter is used only 
        if the includeTestFolder parameter is True)
        The search is recursive because a folder can contains several modules
        
        @param sourceFolder: root source folder (generally ACS, passed int he command line)
        @param includeTestFolder: True to inculde test folders in the scan 
        """
        ret = []
        for root, subdirs, files in os.walk(sourceFolder):
            if root.endswith(os.path.sep+"src") or (includeTestFolder and root.endswith(os.path.sep+"test")):
                if self.containsJavaSources(root):
                    ret.append(root)
        return ret
        
    def getJavaPackagesRoot(self,srcFolders):
        """
        Get the root folders of the java packages in the passed list of folders
        @param srcFolders: the list of folders containg java sources
        @return:  the root of java packages (something like, com, alma..)
        """
        ret = []
        for folder in srcFolders:
            directories = next(os.walk(folder))[1]
            for directory in directories:
                if self.containsJavaSources(folder+os.sep+directory):
                    if ret.count(directory)==0:
                        ret.append(directory)
        return ret

    def buildClasspath(self):
        '''
        Builds the classpath for referenced classes
        '''
        classpath=''
        # Add all jars from ACSROOT/lib
        acsRoot=os.environ['ACSROOT']
        acsRootLib=acsRoot+os.path.sep+"lib"
        files = next(os.walk(acsRootLib))[2]
        for file in files:
            if file.endswith(".jar"):
                classpath=classpath+file+os.path.pathsep
        
        # Add jars from JACORB_HOME/lib
        jacorbHome=os.environ['JACORB_HOME']
        jacorbHomeLib=jacorbHome+os.path.sep+"lib"
        files = next(os.walk(jacorbHomeLib))[2]
        for file in files:
            if file.endswith(".jar"):
                classpath=classpath+file+os.path.pathsep
        # Add jars from JACORB_HOME/lib/endorsed
        jacorbHomeLibEndorsed=jacorbHomeLib+os.path.sep+"endorsed"
        files = next(os.walk(jacorbHomeLibEndorsed))[2]
        for file in files:
            if file.endswith(".jar"):
                classpath=classpath+file+os.path.pathsep
        return classpath

    def buildJavadocCmd(self,dest,srcFolders,pkgs):
        '''
        Build the command to invoke javadoc with subprocess.call.
        javadoc must be invoked with a command line like
        javadoc -d ./html -splitIndex -windowtitle 'ACS 2016.4' -J-Xmx180m -sourcepath ./src -subpackages alma:com
        
        @param dest The destination folder where javadoc creates html
        @param srcFolders The folders containing java sources
        @param pkgs The package roots (alma, com, cern..)
        @return: a list of parameteres to invoke javadoc 
        '''
        sources = ''
        for folder in srcFolders:
            sources = sources + folder+os.path.pathsep
        
        packages = ''
        for pkg in pkgs:
            packages = packages + pkg+os.path.pathsep  
        
        ret=[]
        ret.append("javadoc")
        ret.append("-d")
        ret.append(dest)
        ret.append('-splitIndex')
        ret.append('-windowtitle')
        ret.append(os.environ['ALMASW_RELEASE'])
        ret.append('-J-Xmx250m')
        ret.append('-sourcepath')
        ret.append(sources)
        ret.append('-subpackages')
        ret.append(packages)
        ret.append("-classpath")
        ret.append(self.buildClasspath())
        ret.append("-quiet") # Suppress non-warning non-error messages
        ret.append("-author") #Adds the author to generated docs
        ret.append("-doctitle")
        ret.append(os.environ['ALMASW_RELEASE']+" API documentation")
        ret.append("-header")
        ret.append('<EM>'+os.environ['ALMASW_RELEASE']+'</EM>')
        ret.append("-footer")
        ret.append('<EM>Generated at '+str(datetime.date.today())+'</EM>')
        ret.append("-charset")
        ret.append("iso-8859-15")
        return ret
        

if __name__=="__main__":
    # javadoc -d ./html -splitIndex -windowtitle 'ACS 2016.4' -J-Xmx180m -sourcepath ./src -subpackages alma:com
    
    # Parse the command line
    parser = OptionParser()
    parser.add_option("-d", "--destFolder", help="HTML destination folder", default=".",action="store", type="string", dest="destFolder")
    parser.add_option("-s", "--sourceFolder", help="ACS source folder", default=".",action="store", type="string", dest="srcFolder")
    parser.add_option("-t", "--test", help="Include java sources from test folders", action="store_true", dest="includeTest", default=False)
    (options, args) = parser.parse_args()
    
    print 
    builder = AcsJavadocBuilder(options.srcFolder, options.destFolder, options.includeTest)
    builder.buildJavadocs()
    
#
# ___oOo___
