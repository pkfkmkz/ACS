/*
* ALMA - Atacama Large Millimiter Array
* Copyright (c) National Astronomical Observatory of Japan, 2017 
* 
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
* 
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
* 
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/
package alma.acs.bulkdata;

import alma.acs.logging.AcsLogLevel;

import com.rti.ndds.config.LoggerDevice;
import com.rti.ndds.config.LogCategory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.logging.Logger;
import java.util.stream.Stream;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.commons.lang.Validate;
/**
 * This class provides a singleton object that holds the global configuration
 * of BulkData Java library. This global configuration affects all the code
 * that uses this BulkData Java API running in the same Java.
 *
 * <p>
 * Write unit test for this class.
 *
 * @author Takashi Nakamoto
 */
public class BulkDataNTGlobalConfiguration {
    private final static BulkDataNTGlobalConfiguration singleton
        = new BulkDataNTGlobalConfiguration();

    /**
     * This method returns the singleton instance of this class.
     *
     * @return The singleton instance of this class.
     */
    public static BulkDataNTGlobalConfiguration getInstance() {
        return singleton;
    }

    /**
     * This constants is the name of the environmental variable that
     * that specifies the verbosity of the log messages provided by
     * DDS library.
     */
    public static final String VERBOSITY_VAR_NAME = "BULKDATA_NT_DEBUG";

    private Optional<Logger> logger;
    private Object loggerLock = new Object();

    private BulkDataNTDomainParticipantFactory factory;
    /**
     * This variable holds the copy of all environmental variables in a memory.
     */
    private Map<String,String> envVars;

    private BulkDataNTGlobalConfiguration() {
        Logger newLogger = Logger.getLogger(this.getClass()
                                            .getPackage()
                                            .getName());
        try {
            setLogger(newLogger);
        } catch (IOException ex) {
            // If setLogger() fails, it means that DDS library throws
            // IOException when setting logger. Let's use the default
            // logger only for the log messages generated by this
            // BulkData library, and let DDS library outputs the
            // log messages to its default location (the standard output).
            this.logger = Optional.of(newLogger);
            newLogger.log(AcsLogLevel.WARNING,
                          "Failed to set the logger for DDS library.", ex);
        }
        this.factory = BulkDataNTDomainParticipantFactory.getInstance();
        this.envVars = new HashMap<String, String>(System.getenv());
    }

    /**
     * This method replaces the current global logger with the specified
     * logger. This is useful if you want to transfer the log messages that
     * BulkData Java library generates to the logger of your application
     * or container.
     *
     * <p>
     * Note that the log messages that are specific to Stream or Flow are
     * not logged by the global logger. The global logger collects only
     * the following kinds of log messages:
     *
     * <ul>
     * <li>The log messages generated by BulkData Java library that are not
     *     bound to any Stream or Flow. For example, the log messages generated
     *     by {@link #loadQosXml()} are logged by the global logger.
     * <li>The log messages generated by the underlying RTI DDS library. The RTI
     *     DDS library passes the log messages to only one logger within one
     *     JVM process. Logger per DDS entity is not supported.
     * <li>
     * </ul>
     *
     * The new logger takes effect after the successful execution of this 
     * method. It is recommended that your application calls this method
     * at the beginning of the application before creating any Stream.
     *
     * @param logger Logger instance. Specify null to disable global logging.
     *
     * @throws IOException
     * if the underlying DDS library throws {@link IOException}. Note that
     * Java API document of the underlying RTI DDS library does not describe
     * on what condition this exception happens. This method just throws
     * the exception that the underlying library throws. The application 
     * programmer can simply ignore this exception if the logging is not
     * critical for her/his application. In many cases, logging is not
     * critical and the application can keep working without logger.
     */
    public void setLogger(Logger logger)
        throws IOException {
        LoggerDevice loggerDevice = new BulkDataNTDdsLoggerDevice(logger);

        synchronized (loggerLock) {
            // The API document of set_output_device() indicates that
            // it may throw IOException, but it does not describe on what
            // occasion it happens.
            //
            // In case the exception happens, this method does not
            // replace the logger in the instance variable (this.logger)
            // to keep consistency. Here, it is assumed that the two
            // statements below are executed in the order, and the
            // second statement is not executed when IOException is
            // thrown by the first statement.
            com.rti.ndds.config.Logger
                .get_instance().set_output_device(loggerDevice);

            this.logger = Optional.ofNullable(logger);
        }
    }

    /**
     * This method sets the verbosity of the log messages generated by
     * the underlying DDS library. The logger for these log messages
     * can be set by {@link #setLogger(Logger)}, and the application
     * programmers can changes its verbosity with this method.
     *
     * <p>
     * Until either this method or {@link #setDdsLogVerbosityFromEnvVar()} is
     * called, the DDS library uses the default verbosity, which is
     * {@link BulkDataNTDdsLogVerbosity#ERROR}.
     * 
     * @param verbosity The new verbosity.
     *
     * @throws IllegalArgumentException
     * if verbosity is null.
     */
    public void setDdsLogVerbosity(BulkDataNTDdsLogVerbosity verbosity) {
        Validate.notNull(verbosity);

        com.rti.ndds.config.Logger ddsLogger
            = com.rti.ndds.config.Logger.get_instance();
        LogCategory category
            = LogCategory.NDDS_CONFIG_LOG_CATEGORY_API;
        ddsLogger.set_verbosity_by_category(category,
                                            verbosity.getDdsLogVerbosity());
    }

    /**
     * This method reads the value in the environmental variable
     * {@value #VERBOSITY_VAR_NAME}, and sets the verbosity of the log messages
     * generated by the underlying DDS library.
     *
     * <p>
     * Until either this method or
     * {@link #setDdsLogVerbosity(BulkDataNTDdsLogVerbosity)} is called,
     * the DDS library uses the default verbosity, which is
     * {@link BulkDataNTDdsLogVerbosity#ERROR}.
     *
     * <p>
     * This method is provided to keep the compatibility of your application
     * with the application that uses BulkData C++ API, but the behavior is
     * slightly different. In case of this Java API, this method throws
     * {@link InvalidEnvironmentalVariableException}
     * if the environmental variabe is not defined, or if it contains an
     * invalid value. By catching this exception, the application programmer
     * can set the default verbosity according to the application's needs.
     * (C++ API automatically sets the verbosity to WARNING level and
     * the application cannot change it).
     *
     * <p>
     * The valid values are the integer values that can be obtained by
     * the code shown below:
     * 
     * <pre>{@code
        List<Integer> values = 
            Arrays.stream(BulkDataNTDdsLogVerbosity.values())
            .map(v -> v.getLogLevel())
            .collect(Collectors.toList());
     * }</pre>
     *
     * One other difference from C++ API is that this Java API allows 0 as the
     * value in the the environmental variable, which means only error messages
     * will be logged.
     *
     * @throws InvalidEnvironmentalVariableException
     * if the evirnomental variable {@value #VERBOSITY_VAR_NAME} is not defined,
     * or if it contians an invalid value.
     *
     * @see #setDdsLogVerbosity(BulkDataNTDdsLogVerbosity)
     */
    public void setDdsLogVerbosityFromEnvVar()
        throws InvalidEnvironmentalVariableException {

        String bulkDataNtDebug = getenv(VERBOSITY_VAR_NAME);
        if (bulkDataNtDebug == null) {
            throw new InvalidEnvironmentalVariableException(VERBOSITY_VAR_NAME +
                                                            " is not defined.",
                                                            VERBOSITY_VAR_NAME, null);
        }
        
        try {
            int debugLevel = Integer.parseInt(bulkDataNtDebug);

            String expMsg
                = String.format("%s contains an invalid value \"%d\".",
                                VERBOSITY_VAR_NAME, debugLevel);
            BulkDataNTDdsLogVerbosity verbosity =
                Arrays.stream(BulkDataNTDdsLogVerbosity.values())
                .filter(v -> v.getLogLevel() == debugLevel)
                .findFirst()
                .orElseThrow(() ->
                             new InvalidEnvironmentalVariableException(expMsg,
                                                                       VERBOSITY_VAR_NAME,
                                                                       bulkDataNtDebug));
            setDdsLogVerbosity(verbosity);
        } catch (NumberFormatException ex) {
            throw new InvalidEnvironmentalVariableException(VERBOSITY_VAR_NAME +
                                                   " contains non-integer value" +
                                                   " \"" + bulkDataNtDebug + "\".",
                                                   VERBOSITY_VAR_NAME,
                                                   bulkDataNtDebug);
        }
    }

    /**
     * This method returns the current global logger of BulkData Java library.
     *
     * <p>
     * This is the same logger configured by {@link #setLogger(Logger)} if it
     * has been called so far. If null was passed to {@link #setLoger(Logger)},
     * this method returns an empty value, which means that the global logging
     * is disabled.
     *
     * <p>
     * If {@link #setLogger(Logger)} has not been called so far, the default
     * logger prepared by this library is returned.
     *
     * @return The current global logger. It can be an empty if the global
     *         logging is disabled.
     *
     * @see #setLogger(Logger)
     */
    Optional<Logger> getLogger() {
        synchronized (loggerLock) {
            return logger;
        }
    }

    /**
     * This method searches a QoS XML flie in ACS environment, and loads it
     * if it is found. Searching is done by {@link #findQosXmlInAcsEnv()}.
     *
     * <p>
     * Either this method or {@link #loadQosXml(Path)} must be called once before
     * creating any Stream. Otherwise, {@link QosXmlNotLoadedException} will be
     * thrown when creating a new Stream.
     *
     * @throws NoQosXmlInAcsEnvironmentException
     * if QoS XML file for BulkData cannot be found in ACS environment.
     * @throws CannotLoadQosXmlSchemaException
     * if QoS XML schema file cannot be loaded correctly from RTI DDS
     * product distribution.
     * @throws CannotReadQosXmlException
     * if an I/O error happens wile reading the data from the found QoS XML
     * flie.
     * @throws InvalidQosXmlException
     * if the given QoS XML has syntax error(s), or if the validation with the
     * schema fails.
     * @throws FailedToGetQosException
     * if the underlying DDS library fails to get the current QoS settings.
     * @throws FailedToSetQosException
     * if the underlying DDS library fails to set the loaded QoS settings.
     *
     * @see #loadQosXml(Path)
     */
    public void loadQosXml()
        throws NoQosXmlInAcsEnvironmentException,
               CannotLoadQosXmlSchemaException,
               CannotReadQosXmlException,
               InvalidQosXmlException,
               FailedToGetQosException,
               FailedToSetQosException {
        loadQosXml(findQosXmlInAcsEnv());
    }

    /**
     * This method loads a QoS XML file from the given path.
     *
     * <p>
     * If the given QoS XML flie is successfully loaded, the current QoS
     * settings are overrided by the ones in the given QoS XML file.
     *
     * <p>
     * Either this method or {@link #loadQosXml()} must be called once before
     * creating any Stream. Otherwise, {@link QosXmlNotLoadedException} will be
     * thrown when creating a new Stream.
     *
     * @param xmlPath The path of the QoS XML file in a local file system.
     *
     * @throws CannotLoadQosXmlSchemaException
     * if QoS XML schema file cannot be loaded correctly from RTI DDS
     * product distribution.
     * @throws CannotReadQosXmlException
     * if a readable file does not exist in the given path, or if an I/O error
     * happens while reading the data from the file.
     * @throws InvalidQosXmlException
     * if the given QoS XML has syntax error(s), or if the validation with the
     * schema fails.
     * @throws FailedToGetQosException
     * if the underlying DDS library fails to get the current QoS settings.
     * @throws FailedToSetQosException
     * if the underlying DDS library fails to set the loaded QoS settings.
     */
    public void loadQosXml(Path xmlPath)
        throws CannotLoadQosXmlSchemaException,
               CannotReadQosXmlException,
               InvalidQosXmlException,
               FailedToGetQosException,
               FailedToSetQosException {
        logger.ifPresent(l -> l.log(AcsLogLevel.INFO,
                                    "Going to use: " + xmlPath + 
                                    "QoS profile."));

        try {
            synchronized (factory) {
                factory.loadQosXml(Files.newInputStream(xmlPath));
            }
        } catch (IOException ex) {
            String msg
                = "Failed to read QoS XML at " + xmlPath + ".";
            throw new CannotReadQosXmlException(msg, ex, xmlPath);
        } catch (InvalidQosXmlException ex) {
            String msg
                = "QoS XML contents in " + xmlPath + " is invalid. There is "
                + "XML syntax error(s), or the validation using the schema at "
                + ex.getSchema().getPath() + " failed.";
            throw new InvalidQosXmlException(msg,
                                             ex.getCause(),
                                             ex.getSchema(),
                                             xmlPath);
        } catch (ParserConfigurationException | 
                 TransformerException ex) {
            String msg
                = "Unknown exception happened while preparing for XML parser "
                + "or when converting XML document at " + xmlPath + " into a "
                + "string.";
            throw new CannotReadQosXmlException(msg, ex, xmlPath);
        }
    }

    private static final String MODPATH = "MODPATH";
    private static final String MODROOT = "MODROOT";
    private static final String INTROOT = "INTROOT";
    private static final String INTLIST = "INTLIST";
    private static final String ACSROOT = "ACSROOT";

    /**
     * This method tries to find QoS XML file in ACS environment. The search
     * is done in the following:
     *
     * <ol>
     * <li>
     *   If environmental variable LOCATION is defined:
     *   <ol>
     *   <li>../config/bulkDataNTDefaultQosProfiles.${LOCATION}.xml
     *       (if MODPATH is defined)
     *   <li>${MODROOT}/config/bulkDataNTDefaultQosProfiles.${LOCATION}.xml
     *       (if MODROOT is defined)
     *   <li>${INTROOT}/config/bulkDataNTDefaultQosProfiles.${LOCATION}.xml
     *       (if INTROOT is defined)
     *   <li>${directory}/config/bulkDataNTDefaultQosProfiles.${LOCATION}.xml
     *       for each directory defined in INTLIST.
     *   <li>${ACSROOT}/config/bulkDataNTDefaultQosProfiles.${LOCATION}.xml
     *       (if ACSROOT is defined)
     *   </ol>
     * <li>../config/bulkDataNTDefaultQosProfiles.default.xml
     * <li>${MODROOT}/config/bulkDataNTDefaultQosProfiles.default.xml
     *     (if MODROOT is defined)
     * <li>${INTROOT}/config/bulkDataNTDefaultQosProfiles.default.xml
     *     (if INTROOT is defined)
     * <li>${directory}/config/bulkDataNTDefaultQosProfiles.default.xml
     *     for each directory defined in INTLIST.
     * <li>${ACSROOT}/config/bulkDataNTDefaultQosProfiles.default.xml
     *     (if ACSROOT is defined)
     * </ol>
     * 
     * <p>
     * If a readable file is found in one of the paths described above, this
     * method returns that path.
     *
     * @return Path of the found file.
     *
     * @throws NoQosXmlInAcsEnvironmentException
     * if no readable file cannot be found in the prescribed paths.
     */
    public static Path findQosXmlInAcsEnv()
        throws NoQosXmlInAcsEnvironmentException {
        return
            Stream.of(MODPATH, MODROOT, INTROOT, INTLIST, ACSROOT)
            .<String>flatMap(var -> {
                    switch(var) {
                    case MODPATH:
                        return Stream.of(getenv(var) == null ? null : "..");
                    case INTLIST:
                        return Optional.ofNullable(getenv(var))
                            .<Stream<String>>map(list -> Stream.of(list.split(":"))).orElse(null);
                    default:
                        return Stream.of(getenv(var));
                    }
                })
            .filter(dirStr -> dirStr != null && !dirStr.isEmpty())
            .map(dirStr -> 
                 FileSystems
                 .getDefault()
                 .getPath(dirStr)
                 .resolve("config"))
            .flatMap(dirPath -> 
                     Stream.of(getenv("LOCATION"), "default")
                     .filter(s -> s != null)
                     .map(loc ->
                          String.format("bulkDataNTDefaultQosProfiles.%s.xml",
                                        loc))
                     .map(name -> dirPath.resolve(name)))
            .filter(path -> Files.isReadable(path))
            .findFirst()
            .orElseThrow(() -> new NoQosXmlInAcsEnvironmentException());
    }

    /**
     * This method does the same thing as {@link System#getenv(String)} except
     * some variables may have been deleted, modified or added during the unit
     * test.
     *
     * @param name The variable name. Must not be null.
     *
     * @return The value in the variable, or null if the variable does not exist.
     */
    String getEnv(String name) {
        return envVars.get(name);
    }

    /**
     * This method overrides the environmental variable returned by
     * {@link getenv(String)}. This method must be called only in the test code
     * that tests the methods whose behavior depends on environmental variables.
     *
     * @param name The variable name. Must not be null.
     * @param value The value to set. Specify null to delete the variable.
     */
    void setEnv(String name, String value) {
        envVars.put(name, value);
    }

    /**
     * Static version of {@link BulkDataNTGlobalConfiguration#getEnv(String)}.
     *
     * @param name The variable name. Must not be null.
     *
     * @return The value in the variable, or null if the variable does not exist.
     */
    static String getenv(String name) {
        return singleton.getEnv(name);
    }

    /**
     * Static version of
     * {@link BulkDataNTGlobalConfiguration#setEnv(String, String)}.
     *
     * @param name The variable name. Must not be null.
     * @param value The value to set. Specify null to delete the variable.
     */
    static void setenv(String name, String value) {
        singleton.setEnv(name, value);
    }
}
