#ifndef _DDS_SUBSCRIBER_H
#define _DDS_SUBSCRIBER_H

#include <DDSHelper.h>
#include <acsddsncDataReaderListener.h>
#include <dds/DCPS/SubscriberImpl.h>
#include <ACSErrTypeCommon.h>

namespace ddsnc{

	/**
	 * The Subscriber implementation of ACS Notification Channel based on DDS
	 *
	 * @see DDSHelper
	 * @author Jorge Avarias <javarias[at]inf.utfsm.cl>
	 * @author Danilo C. Zanella <danilo.zanella[at]iag.usp.br>
 	 */
	class DDSSubscriber : public ddsnc::DDSHelper{
		private:
		DDS::Subscriber_var sub;
		DDS::DataReaderListener_var listener;
    		DDS::DataReader_var dr;
    		DDS::TypeSupport_var ts_;
		
		/**
		 * Creates the subscriber with default QoS or QoS with a partition
		 *
		 * @see initialize();
		 */
		void createSubscriber();

		/**
		 * Initialize the DataReader with Qos. This method leaves the Subscriber
		 * initializated when is executed.
		 *
		 * @see drQos
		 */
    		void initializeDataReader();

		protected:
		DDS::SubscriberQos subQos;

		public:
		DDS::DataReaderQos drQos;

		/**
		 * Constructor of the class.
		 *
		 * @see DDSHelper
		 */
		DDSSubscriber(CORBA::String_var channel_name, CORBA::String_var qosProfile, DDS::DomainId_t id);
		
		~DDSSubscriber()
		{
		}

		void consumerReady();

		/**
		 * The method maintains the name provided by the old acsnc API.
		 * Actually this function initializes the DataReader listener.
		 *
		 * The <type> corresponds to the name of data type (without namespace)
		 * defined in the idl file, the classes required by the template are 
		 * autogenerated by dcps_ts.pl tools and are specific to the data 
		 * type defined.
		 *
		 * @tparam D <type> struct
		 * @tparam DR <type>DataReader class
		 * @tparam DRV <type>DataReader_var class
		 * @param (*templateFunction)(D, void *) callback function to handle
		 * data received by DataReaderListener
		 * @param *handlerParam 
		 */
		template <class DRV, class DR, class D>
			void addSubscription(
					void (*templateFunction)(D, void *), void *handlerParam=0)
			{
        	ACS_TRACE(__PRETTY_FUNCTION__);

			  LOG_TO_DEVELOPER(LM_INFO, "Add subscription");

				listener = new ddsnc::ACSDDSNCDataReaderListener
					 <DRV,DR,D>(templateFunction, handlerParam);

        // Check if subscriber was created
      	if(CORBA::is_nil(listener.in()))
        {
      		ACSErrTypeCommon::GenericErrorExImpl ex(__FILE__,
                                                  __LINE__,
                                                  __PRETTY_FUNCTION__
                                                  );
          std::string msg = "Listener is nil.";
      		ex.setErrorDesc(msg.c_str());
      		ex.log();
      		throw ex.getGenericErrorEx();
      	}
				
			}


		/**
		 * Create the participant, initialize the subscriber with the partition
		 * provided in the channelName constructor parameter, if there is not
		 * partition, initialize the subscriber with default QoS properties, then
		 * initialize the transport for the participant, create the subscriber
		 * and initialize the topic with topicNanme provided as parameter of
		 * the constructor and with data type support defined by templates and
		 * finally initialize the data reader QoS with default values
		 *
		 * The <type> corresponds to the name of data type (without namespace)
		 * defined in the idl file, the classes required by the template are 
		 * autogenerated by dcps_ts.pl tools and are specific to the data 
		 * type defined.
		 *
		 *
		 * @tparam TS <type>TypeSupport class
		 * @tparam TSV <type>TypeSupport_var class
		 * @tparam TSI <type>TypeSupportImpl class
		 */
		template <class TS, class TSV, class TSI>
		void initialize()
		{
      ACS_TRACE(__PRETTY_FUNCTION__);

      LOG_TO_DEVELOPER(LM_INFO, "Initializing...");

      // Create participant
			createParticipant();

      // Create Subscriber
      createSubscriber();

			/* Initialize Type Support*/
      ts_ = new TSI();
      TSV ts = TS::_narrow(ts_.in());
			if (DDS::RETCODE_OK != ts->register_type(participant.in(),""))
      {
      		ACSErrTypeCommon::GenericErrorExImpl ex(__FILE__,
                                                  __LINE__,
                                                  __PRETTY_FUNCTION__
                                                  );
          std::stringstream msg;
          msg << "Registering type <"
              << ts->get_type_name()
              << "> failed";
      		ex.setErrorDesc(msg.str().c_str());
      		ex.log();
      		throw ex.getGenericErrorEx();
			}
			
			/* Initialize the Topic*/
			initializeTopic(ts->get_type_name());

			/* Initialize the Data Reader*/
      initializeDataReader();
		
		}
	};
}

/**
 * Create a new DDS Subscriber in an easy way.
 *
 * Create a new DDSSubscribe object, then initialize the subscribe and finally
 * execute the addSubscription function.
 *
 * @see DDSSubscriber()
 * @see initialize()
 * @see addSubscription()
 */
#define ACS_NEW_DDS_SUBSCRIBER(subscriber_p, idlStruct, id, channelName, qosProfileName,  handlerFunc, handlerParam) \
{ \
	subscriber_p= new ddsnc::DDSSubscriber(channelName, qosProfileName, id); \
	subscriber_p->initialize<idlStruct##TypeSupport, idlStruct##TypeSupport_var, idlStruct##TypeSupportImpl>(); \
	subscriber_p->addSubscription<idlStruct##DataReader_var, idlStruct##DataReader, idlStruct>(handlerFunc, handlerParam); \
}

#endif
