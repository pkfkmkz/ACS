/*
* ALMA - Atacama Large Millimiter Array
* Copyright (c) National Astronomical Observatory of Japan, 2017 
* 
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
* 
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
* 
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/
package alma.acs.bulkdata;

import alma.acs.logging.ClientLogManager;
import java.nio.charset.StandardCharsets;
import java.util.Optional;
import java.util.logging.Logger;

/**
 * This class shows an example usage of BulkData Sender using Java API
 * in this package. This class was created to verify that the code
 * snippet in package-info.java can be compiled and run properly.
 *
 * @author Takashi Nakamoto
 */
class BulkDataNTSampleSender {
    public static void main(String[] args) throws Exception {
        BulkDataNTGlobalConfiguration globalConf
            = BulkDataNTGlobalConfiguration.getInstance();

        // Set the destination of the log messages that are not bound 
        // to specific Stream or Flow. The log messages generated by
        // the underlying RTI DDS library will be also logged by the
        // specified logger. This is not mandatory, but is useful
        // when you encounter an error and debug the problem.
        //
        // This example specifies the logger that is provided by ACS.
        Logger logger
           = ClientLogManager.getAcsLogManager()
             .getLoggerForApplication("BulkDataNTSampleSender", true);
        globalConf.setLogger(logger);

        // Set the verbosity of the underlying RTI DDS library.
        // To keep your application compatibility with the one that uses
        // C++ API, set the verbosity as shown below.
        //
        // TODO: it seems that BULKDATA_NT_DEBUG is not respected... check why
        try {
            globalConf.setDdsLogVerbosityFromEnvVar();
        } catch (InvalidEnvironmentalVariableException ex) {
            // Use WARNING level if BULKDATA_NT_DEBUG is not defined or
            // contains an invalid value.
            globalConf.setDdsLogVerbosity(BulkDataNTDdsLogVerbosity.WARNING);
        }

        // Load QoS XML file from ACS environment. This is mandatory.
        // If you forget to call this method, QosXmlNotLoadedException
        // will be thrown when creating a new Stream.
        //
        // If you want to load another QoS XML file in your local instead
        // of the one prepared by ACS, call loadQosXml(Path) instead.
        globalConf.loadQosXml();
       
        // Create a new Stream.
        BulkDataNTSenderStreamConfiguration streamConf
            = new BulkDataNTSenderStreamConfigurationDefault();
        BulkDataNTSenderStream stream
            = new BulkDataNTSenderStream("s1", streamConf);
       
        // Create a new Flow.
        //
        // The second argument of createFlow() is the listener for the events
        // raised by the Flow. If you do not need it, specify an empty value.
        BulkDataNTSenderFlowConfiguration flowConf
            = new BulkDataNTSenderFlowConfigurationDefault();
        BulkDataNTSenderFlow flow
            = stream.createFlow("f1", Optional.empty(), flowConf);
       
        // Tell the receiver that you are going to send data.
        flow.startSend("DefaultParameter".getBytes(StandardCharsets.US_ASCII));
       
        // Send arbitrary length of serialized data. You can call sendData()
        // repeatedly instead of calling once.
        byte[] data = new byte[10];
        flow.sendData(data);
       
        // Tell the receiver that you finished sending data.
        flow.stopSend();
       
        // If you want, you can call startSend() again and repeat the same
        // procedure to send another data.
       
        // Delete Flow "f1" from Stream "s1". You do not need to do this
        // because stream.destroy() that is called later automatically deletes
        // all Flows in the Stream.
        stream.deleteFlow(flow);
       
        // You need to make sure that destroy() is called only once before
        // your application finishes. Otherwise, the application may hang
        // up and not keep living until you forcibly kill it.
        stream.destroy();
    }
}
