#################################################
# set standard targets.                         #
#################################################
# define 'all' as the default target (by definition, the default target is
# the first that make encounters). 

# force each standard target name to be an independent target
# (i.e., it will not be affected by an actual file with the same name)
.PHONY : all
.PHONY : clean
.PHONY : clean_dist
.PHONY : man
.PHONY : install
.PHONY : test

#
# set standard action for 'man'
# -----------------------------
#
#    foreach section in the MANSECTIONS list, extract the man pages
#    from the appropriate input file list
.PHONY : do_man_hello
do_man_hello:
	-@$(ECHO) "\nman-pages..."

#
# generate doxygen documentation
# 
.PHONY : doxygen
doxygen:
	-@$(ECHO) "..doxygen $(DOXYGEN_PDF)"
	-$(AT) doxygenize $(DOXYGEN_PDF)

#
# Convert ASCII document into Framemaker MIF format
#
.PHONY : do_A2MIF
do_A2MIF:
	-@$(ECHO) " ASCII to MIF:"
ifneq ($(strip $(ASCII_TO_MIF)),)
	-$(AT) for member in $(ASCII_TO_MIF) ; do $(ECHO) "\t$${member}"; docA2MIF $${member} ../doc/`basename $${member}`.mif $(OUTPUT); done
	-@$(ECHO) ""
endif

.PHONY : do_man
do_man:  do_pythondoc doxygen do_man_hello $(addprefix man, $(MANSECTIONS)) manl do_A2MIF

.PHONY : man%
man%:
	-@$(ECHO) "....section $*:"
	-$(AT) mkdir -p ../doc ../man/man$*
	-$(AT) for member in $(MAN$*) ; do $(ECHO) "\t$${member}"; docDoManPages $${member} $* $(LASTCHANGE) $(OUTPUT); done

#
# generate local manpages (not to be installed)
#
.PHONY : manl
manl:
	-@$(ECHO) "..local pages:"
ifneq ($(strip $(MANl)),)
	-$(AT) mkdir -p ../man/manl
	-$(AT) for member in $(MANl) ; do $(ECHO) "\t$${member}"; docDoManPages $${member} l $(LASTCHANGE) $(OUTPUT); done
endif

.PHONY : clean_dist
clean_dist: clean  $(CLEAN_DIST_TARGET) clean_tat_session

.PHONY : clean_all
# ICT-5703: execute find as intended (i.e. not only using the last pattern in the list),
# and look only for particular files (exclude directories named "core")
clean_all: $(CLEAN_TARGET)
	-@$(ECHO) "Cleaning up .\c"
	-@$(ECHO) " .\c"
	-$(AT)find .. -type f \( -name \#\* -o -name core -o -name \*\.gdb_history \) -print | $(XARGS) -i $(RM) {}
ifneq ($(strip $(MANSECTIONS)),)
	-$(AT)  for i in $(MANSECTIONS) ; \
		do \
		    if [ -d ../man/man$${i} ];\
		    then \
		        find ../man/man$${i} -type f -print | $(XARGS) grep -l -s "This Man Page has been automatically produced. DO NOT EDIT THIS FILE!" | $(XARGS) $(RM) acsMake_clean_manpages  ;\
		    else \
			$(ECHO) "\n\tWARNING: '$${i}' is in MANSECTIONS but ../man/man$${i} does not exists." $(OUTPUT);\
		    fi ; \
		done
endif
	-$(AT)  if [ -d ../doc ];\
		then \
		    find ../doc -type f -print | $(XARGS) grep -l -s "This file has been automatically produced. DO NOT EDIT THIS FILE!" | $(XARGS) $(RM) acsMake_clean_manpages ;\
		fi
ifneq ($(strip $(MANl)),)
	-$(AT)  if [ -d ../man/manl ];\
		then \
	            find ../man/manl -type f -print | $(XARGS) grep -l -s "This Man Page has been automatically produced. DO NOT EDIT THIS FILE!" | $(XARGS) $(RM) acsMake_clean_manpages  ;\
		fi
endif
	-@$(ECHO) " .\c"
	-$(AT) $(RM) acsMake_clean_testReport ./*.rep
#
# clean TAT files - if tat has not been executed with the "-nc" flag
#
ifndef MAKE_FROMTAT
	-@$(ECHO) " .\c"
	-$(AT)  currentdir=`pwd`;\
	  	current=`basename $$currentdir`;\
		if [ -d ../test/tatlogs -a $$current = "test" ] ;\
		then \
	            $(RM) ../test/tatlogs;\
		fi
endif
#
# clean Doxygen files
#
	-@$(ECHO) " ."
# "doxygenize clean" just recursvile removes ../doc/idl ../doc/api,
# in a bit of a contrived way. So better do this here directly.
#	-$(AT) doxygenize clean
	-$(AT) $(RM) ../doc/idl ../doc/api

.PHONY : clean_dependencies
clean_dependencies:
	-$(AT) $(RM) $(clean_dependencies_target)
	-$(AT) $(ECHO) "Dependency files cleaned..."

#
# clean the directory structure if it's empty
#
.PHONY:
clean_tat_session:
	$(AT)if [ -f .testSessions ]; then echo "=== Cleaning TAT session ===" ; tat -nc cleanEnv; fi


CLEAN_DIST_TARGET += clean_dist_all
.PHONY : clean_dist_all
# ICT-5630: do not remove directories that contain only symlinks
#    (Note: "ls -A <dir>" is about 15x faster than "find <dir> ( -type f -o -type l )"
#     and still 20% faster than "find <dir> -empty")" ...)
# ICT-5703: execute find as intended (i.e. not only using the last pattern in the list)
clean_dist_all:
	-@$(ECHO) " .\c"
	-$(AT)if [ "$(SHLIB_EXT)" == "" ]; then \
	    find .. -name \*\.o -o -name \*\~ -o -name \.\*\~ | $(XARGS) -i $(RM) {}    $(OUTPUT) ; \
	else \
	    find .. -name \*\.o -o -name \*\~ -o -name \.\*\~ -o -name \*\.$(SHLIB_EXT) | $(XARGS) -i $(RM) {}    $(OUTPUT); \
	fi
	$(AT)echo "Cleaning empty directories..."
ifneq ($(strip $(MANSECTIONS)),)
	$(AT) for i in $(MANSECTIONS) l ; \
	do \
	    if [ -d ../man/man$${i} ]; then \
	        if [ "`/bin/ls -A ../man/man$${i}`" == "" ]; then \
	            $(RM) ../man/man$${i} ;\
	        fi; \
	    fi; \
	done
endif
	$(AT)for dir in $(foreach dir, $(CREATE_DIRS) man, $(dir)); \
	do \
	    if [ -d ../$${dir} ];  then \
	        if [ "`/bin/ls -A ../$${dir}`" == "" ]; then \
	            $(RM) ../$${dir} ;\
		fi; \
	    fi; \
	done


# define PHONY all names used as targets
.PHONY : install_all
.PHONY : install_includes
.PHONY : install_CDB-Schemas
.PHONY : install_files
.PHONY : install_man
.PHONY : install_rtai

#CHECK this part is a possible replacement for acsMakeInstallFiles
# but needs a lot of reworking. Since I need an urgent proof of concept here,
# I just leave it for 'later'.
#


install_begin:
	@echo "Installing into target: $(PRJTOP)"

# CHECK
install_includes: includes_begin $(foreach inc, $(INCLUDES),  install_include_$(inc))
#$(INCLUDE)/`(cd ../include; find . -name $(member) | tail -1 )` )

includes_begin:
	@echo ".....includes:" 

install_include_%:	
# COMP-498: Need to find subdir-location of include file
# COMP-6627: cleaner exclusion of CVS/ and .svn/ administrative subdirectories.
# ICT-5703: use precedence rules of find properly (note that the previous implementation also produced 
#   the same result, but just by "coincidence", due to the presence of the -printf action. The current
#   implementation is more logical/readable and will also work without such additional action).
# The shell code here below to determine how many hits is much faster than piping tFile into "wc -w" !
	$(AT)tFile=`(cd ../include; find . \( ! \( -type d -name CVS -prune -o -name .svn -prune \) \) -name $* -printf "%p ")` ; \
	nrHits=0; for x in $${tFile}; do (( ++nrHits )); done; \
	if [ $${nrHits} -eq 1 ]; then \
		tDir=`dirname $${tFile}` ;\
	 	if [ ! -d $(INCLUDE)/$${tDir} ]; then mkdir -p $(INCLUDE)/$${tDir} ; fi ;\
		$(ECHO) "\t$*" ;\
		cp ../include/$${tFile} $(INCLUDE)/$${tFile}; \
		chmod $(P644) $(INCLUDE)/$${tFile}; \
	elif [ $${nrHits} -gt 1 ]; then  \
		echo "==> multiple $* files under ../include: $${tFile}"; exit 1; \
	elif [ $${nrHits} -eq 0 ]; then  \
		echo "==> $* missing"  ; exit 1; \
	fi

# I eliminate the dependency here below because I am not sure why it is needed
# $(INCLUDE)/${tFile}: ../include/${tFile}" 
#
##############################
install_CDB-Schemas: CDB-Schemas_begin $(foreach member, $(CDB_SCHEMAS), $(CDBS)/$(member).xsd )


CDB-Schemas_begin:
	@echo "...CDB-Schemas:"

$(CDBS)/%.xsd: ../config/CDB/schemas/%.xsd
	-$(AT)echo "$*"
	$(AT)cp ../config/CDB/schemas/$*.xsd $(CDBS)/$*.xsd
	$(AT)chmod $(P644) $(CDBS)/$*.xsd

###############################


ifneq ($(strip $(MANSECTIONS_INSTALL)),)
install_man: 
	-@$(ECHO) ""; $(ECHO)  "....man-pages:"
	-$(AT) $(foreach i, $(MANSECTIONS_INSTALL), $(ECHO) "\tsection $(i)"; cp ../man/man$(i)/*.$(i) $(MAN)/man$(i) ;)
endif

#
# set standard action for 'test'
# A test target is also present in the module Makefile template
# To avoid the warning messages: 
# "overriding commands for target `test'" and 
# "ignoring old commands for target `test'" 
# a variable is used. 
# ---------------------------------
#    execute the TAT test.
#

ifndef NO_TEST_TARGET
acsTest = test
$(acsTest):
	export MAKE_PURE
	tat -nc -v
	@echo " . . . test done"
endif

pureReport:
	$(AT) purecov -export=.purifydir/CoverageReport .purifydir/*.pcv
	$(AT) echo "== Purify coverage report in '.purifydir/CoverageReport'."

pureGUI: 
	$(AT) ls .purifydir/purecov*.pcv > /dev/null 2>&1; if [ $$? = "0" ]; then (purecov -view purecov*.pcv &); fi
	$(AT) ls .purifydir/purify*.pv > /dev/null 2>&1; if [ $$? = "0" ]; then \
		for member in `ls .purifydir/purify*.pv`; \
		do purify -view $$member &  \
		done \
	      fi

pureClean:
	$(AT) $(RM) ../{src,test}/.purifydir/purecov-*.{pcv,pv}
	$(AT) $(RM) ../{src,test}/.purifydir/purify-*.{pcv,pv}
	$(AT) $(RM) ./.purifydir/MemoryReport ./.purifydir/CoverageReport
	$(AT) echo "Purify files cleaned."


.PHONY: gcovClean
gcovClean: $(foreach lib,$(LIBRARY_LIST),clean_gcov_lib_$(lib)) $(foreach exe,$(EXECUTABLE_LIST),clean_gcov_exe_$(exe))
	$(AT)$(ECHO) "Gcov files cleaned."

#################################################
# set standard targets.                         #
#################################################
# NOTE: do_scripts must be execute as first to bootstrap this module
# NOTE: the sequence of these prerequisites seem to play a role in parallelization 
#       in particular that do_exes comes before do_libs
#

.DEFAULT_GOAL := do_all
.PHONY : do_all_aux
do_all_aux : $(_MKDIR) $(ALL_TARGET)

# Use built in Macros for passing on arguments to nested makes, to avoid that
# MACRO=... gets lost on more targets.
# MAKEFLAGS is like export "MAKEFLAGS=w -- MACRO=value"
# -$(MAKEFLAGS) tricks for auto prepending - fails if starting with a whitespace 
# after auto removal of special options, e.g. b.
# Therefore we use the old variant $(MFLAGS) $(MAKEOVERRIDES) which always starts with a dash.
# Must be last option before the target, because a "--" is inserted.
# Todo: Is recursive makefile call needed at all, if no output filtering is in place?

.PHONY : do_all
#!!#do_all : $(if $(strip $(LINK_FILES)),do_links_internal,)
do_all :
#	$(AT) $(MAKE) -f $(THIS_MAKEFILE) DEPENDENCIES=on $(MAKE_FLAGS) do_all_aux
	$(AT) $(MAKE) --no-print-directory -f $(THIS_MAKEFILE) DEPENDENCIES=on $(MAKE_FLAGS) $(MFLAGS) $(MAKEOVERRIDES) do_all_aux

# Todo: Nowhere used
.PHONY : CppFiles
CppFiles: $(addprefix ../object/, $(addsuffix .d, $(CSOURCENAMES)))

.PHONY : install_all
install_all : $(INSTALL_TARGET) 


.PHONY: directory_structure
directory_structure:
	@echo "This target ($@) does nothing and will be removed in future versions"
#
#___oOo___
