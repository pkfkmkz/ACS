diff --git a/dds/DCPS/QOS_XML_Handler/XML_File_Intf.cpp b/dds/DCPS/QOS_XML_Handler/XML_File_Intf.cpp
index 7c02d76f4..d70d923ff 100644
--- a/dds/DCPS/QOS_XML_Handler/XML_File_Intf.cpp
+++ b/dds/DCPS/QOS_XML_Handler/XML_File_Intf.cpp
@@ -3,13 +3,6 @@
 #include "ace/XML_Utils/XML_Typedefs.h"
 #include "ace/XML_Utils/XMLSchema/id_map.hpp"
 
-#include "DataReaderQos_Handler.h"
-#include "DataWriterQos_Handler.h"
-#include "TopicQos_Handler.h"
-#include "PublisherQos_Handler.h"
-#include "SubscriberQos_Handler.h"
-#include "ParticipantQos_Handler.h"
-
 #include "dds/DCPS/debug.h"
 
 OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
@@ -17,343 +10,90 @@ OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
 namespace OpenDDS {
 namespace DCPS {
 
-  QOS_XML_File_Handler::QOS_XML_File_Handler (void)
+  QOS_XML_File_Handler::QOS_XML_File_Handler(void) :
+    QOS_XML_Handler()
   {
   }
 
-  QOS_XML_File_Handler::~QOS_XML_File_Handler (void)
+  QOS_XML_File_Handler::~QOS_XML_File_Handler(void)
   {
   }
 
   DDS::ReturnCode_t
-  QOS_XML_File_Handler::init (const ACE_TCHAR * file)
+  QOS_XML_File_Handler::init(const ACE_TCHAR * file)
   {
     DDS::ReturnCode_t retcode = DDS::RETCODE_OK;
     try
       {
-        if (!XML_Helper_type::XML_HELPER.is_initialized ())
+        if (!XML_Helper_type::XML_HELPER.is_initialized())
           {
-            ACE_ERROR ((LM_ERROR,
-              ACE_TEXT ("QOS_XML_File_Handler::init - ")
-              ACE_TEXT ("Unable to initialize XML_Helper.\n")));
+            ACE_ERROR((LM_ERROR,
+              ACE_TEXT("QOS_XML_File_Handler::init - ")
+              ACE_TEXT("Unable to initialize XML_Helper.\n")));
             return DDS::RETCODE_ERROR;
           }
 
         if (DCPS_debug_level > 9)
           {
-            ACE_DEBUG ((LM_TRACE,
-              ACE_TEXT ("QOS_XML_File_Handler::init - ")
-              ACE_TEXT ("Constructing DOM\n")));
+            ACE_DEBUG((LM_TRACE,
+              ACE_TEXT("QOS_XML_File_Handler::init - ")
+              ACE_TEXT("Constructing DOM\n")));
           }
 
         XERCES_CPP_NAMESPACE::DOMDocument *dom =
-          XML_Helper_type::XML_HELPER.create_dom (file);
+          XML_Helper_type::XML_HELPER.create_dom(file);
 
         if (dom == 0)
           {
             if (DCPS_debug_level > 1)
               {
-                ACE_ERROR ((LM_ERROR,
-                  ACE_TEXT ("QOS_XML_File_Handler::init - ")
-                  ACE_TEXT ("Failed to open file %s\n"),
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("QOS_XML_File_Handler::init - ")
+                  ACE_TEXT("Failed to open file %s\n"),
                   file));
               }
             return DDS::RETCODE_ERROR;
           }
 
-        XERCES_CPP_NAMESPACE::DOMElement *profile_dom = dom->getDocumentElement ();
+        XERCES_CPP_NAMESPACE::DOMElement *profile_dom = dom->getDocumentElement();
 
         if (DCPS_debug_level > 9)
           {
-            ACE_DEBUG ((LM_TRACE,
-              ACE_TEXT ("QOS_XML_File_Handler::init - ")
-              ACE_TEXT ("DOMElement pointer: %u\n"), profile_dom));
+            ACE_DEBUG((LM_TRACE,
+              ACE_TEXT("QOS_XML_File_Handler::init - ")
+              ACE_TEXT("DOMElement pointer: %u\n"), profile_dom));
           }
 
-        ID_Map::TSS_ID_Map* TSS_ID_Map (ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance());
-        (*TSS_ID_Map)->reset ();
+        ID_Map::TSS_ID_Map* TSS_ID_Map(ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance());
+        (*TSS_ID_Map)->reset();
 
-        this->profiles_ = dds::reader::dds (dom);
+        profiles_ = dds::reader::dds(dom);
       }
     catch (const CORBA::Exception &ex)
       {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::init - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML <%C> into IDL: %C\n"),
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_File_Handler::init - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML <%s> into IDL: %C\n"),
           file,
-          ex._info ().c_str ()));
+          ex._info().c_str()));
         retcode = DDS::RETCODE_ERROR;
       }
     catch (...)
       {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::init - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML <%C> into IDL.\n"),
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_File_Handler::init - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML <%s> into IDL.\n"),
           file));
         retcode = DDS::RETCODE_ERROR;
       }
     return retcode;
   }
 
-  ::dds::qosProfile *
-  QOS_XML_File_Handler::get_profile (const char * profile_name)
-  {
-    for (::dds::qosProfile_seq::qos_profile_const_iterator it = this->profiles_.begin_qos_profile ();
-        it != this->profiles_.end_qos_profile ();
-        ++it)
-      {
-        if (ACE_OS::strcmp ((*it)->name ().c_str (), profile_name) == 0)
-          {
-            if (DCPS_debug_level > 7)
-              {
-                ACE_DEBUG ((LM_TRACE,
-                  ACE_TEXT ("QOS_XML_File_Handler::get_profile - ")
-                  ACE_TEXT ("Found profile <%C>\n"),
-                  (*it)->name ().c_str ()));
-              }
-            return it->get();
-          }
-      }
-    if (ACE_OS::strlen (profile_name) == 0)
-      {
-        ACE_ERROR ((LM_DEBUG,
-          ACE_TEXT ("QOS_XML_File_Handler::get_profile - ")
-          ACE_TEXT ("No profile specified\n")));
-      }
-    else
-      {
-        ACE_ERROR ((LM_TRACE,
-          ACE_TEXT ("QOS_XML_File_Handler::get_profile - ")
-          ACE_TEXT ("Did not find profile <%C>\n"),
-          profile_name));
-      }
-    return 0;
-  }
-
-  DDS::ReturnCode_t
-  QOS_XML_File_Handler::get_datawriter_qos (::DDS::DataWriterQos& dw_qos,
-                                            const char * profile_name,
-                                            const char * topic_name)
-  {
-    ACE_UNUSED_ARG (topic_name);
-
-    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
-    try
-      {
-        ::dds::qosProfile * profile = this->get_profile (profile_name);
-        if (profile != 0)
-          {
-            DataWriterQos_Handler::get_datawriter_qos (dw_qos, profile);
-            retcode = ::DDS::RETCODE_OK;
-          }
-        else
-          retcode = DDS::RETCODE_BAD_PARAMETER;
-      }
-    catch (const CORBA::Exception &ex)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_datawriter_qos - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
-          ex._info ().c_str ()));
-        retcode = DDS::RETCODE_ERROR;
-      }
-    catch (...)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_datawriter_qos - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML into IDL.\n")));
-        retcode = DDS::RETCODE_ERROR;
-      }
-
-    return retcode;
-  }
-
-  DDS::ReturnCode_t
-  QOS_XML_File_Handler::get_datareader_qos (::DDS::DataReaderQos& dr_qos,
-                                            const char * profile_name,
-                                            const char * topic_name)
-  {
-    ACE_UNUSED_ARG (topic_name);
-
-    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
-    try
-      {
-        ::dds::qosProfile * profile = this->get_profile (profile_name);
-        if (profile != 0)
-          {
-            DataReaderQos_Handler::get_datareader_qos (dr_qos, profile);
-            retcode = ::DDS::RETCODE_OK;
-          }
-        else
-          retcode = DDS::RETCODE_BAD_PARAMETER;
-      }
-    catch (const CORBA::Exception &ex)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_datareader_qos - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
-          ex._info ().c_str ()));
-        retcode = DDS::RETCODE_ERROR;
-      }
-    catch (...)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_datareader_qos - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML into IDL.\n")));
-        retcode = DDS::RETCODE_ERROR;
-      }
-
-    return retcode;
-  }
-
-  DDS::ReturnCode_t
-  QOS_XML_File_Handler::get_topic_qos (::DDS::TopicQos& tp_qos,
-                                        const char * profile_name,
-                                        const char * topic_name)
-  {
-    ACE_UNUSED_ARG (topic_name);
-
-    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
-    try
-      {
-        ::dds::qosProfile * profile = this->get_profile (profile_name);
-        if (profile != 0)
-          {
-            TopicQos_Handler::get_topic_qos (tp_qos, profile);
-            retcode = ::DDS::RETCODE_OK;
-          }
-        else
-          retcode = DDS::RETCODE_BAD_PARAMETER;
-      }
-    catch (const CORBA::Exception &ex)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_topic_qos - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
-          ex._info ().c_str ()));
-        retcode = DDS::RETCODE_ERROR;
-      }
-    catch (...)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_topic_qos - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML into IDL.\n")));
-        retcode = DDS::RETCODE_ERROR;
-      }
-
-    return retcode;
-  }
-
-  DDS::ReturnCode_t
-  QOS_XML_File_Handler::get_publisher_qos (::DDS::PublisherQos& pub_qos,
-                                            const char * profile_name)
-  {
-    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
-    try
-      {
-        ::dds::qosProfile * profile = this->get_profile (profile_name);
-        if (profile != 0)
-          {
-            PublisherQos_Handler::get_publisher_qos (pub_qos, profile);
-            retcode = ::DDS::RETCODE_OK;
-          }
-        else
-          retcode = DDS::RETCODE_BAD_PARAMETER;
-      }
-    catch (const CORBA::Exception &ex)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_publisher_qos - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
-          ex._info ().c_str ()));
-        retcode = DDS::RETCODE_ERROR;
-      }
-    catch (...)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_publisher_qos - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML into IDL.\n")));
-        retcode = DDS::RETCODE_ERROR;
-      }
-
-    return retcode;
-  }
-
-  DDS::ReturnCode_t
-  QOS_XML_File_Handler::get_subscriber_qos (::DDS::SubscriberQos& sub_qos,
-                                            const char * profile_name)
-  {
-    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
-    try
-      {
-        ::dds::qosProfile * profile = this->get_profile (profile_name);
-        if (profile != 0)
-          {
-            SubscriberQos_Handler::get_subscriber_qos (sub_qos, profile);
-            retcode = ::DDS::RETCODE_OK;
-          }
-        else
-          retcode = DDS::RETCODE_BAD_PARAMETER;
-      }
-    catch (const CORBA::Exception &ex)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_subscriber_qos - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
-          ex._info ().c_str ()));
-        retcode = DDS::RETCODE_ERROR;
-      }
-    catch (...)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_subscriber_qos - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML into IDL.\n")));
-        retcode = DDS::RETCODE_ERROR;
-      }
-
-    return retcode;
-  }
-
-  DDS::ReturnCode_t
-  QOS_XML_File_Handler::get_participant_qos (::DDS::DomainParticipantQos& sub_qos,
-                                            const char * profile_name)
-  {
-    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
-    try
-      {
-        ::dds::qosProfile * profile = this->get_profile (profile_name);
-        if (profile != 0)
-          {
-            ParticipantQos_Handler::get_participant_qos (sub_qos, profile);
-            retcode = ::DDS::RETCODE_OK;
-          }
-        else
-          retcode = DDS::RETCODE_BAD_PARAMETER;
-      }
-    catch (const CORBA::Exception &ex)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_participant_qos - ")
-          ACE_TEXT ("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
-          ex._info ().c_str ()));
-        retcode = DDS::RETCODE_ERROR;
-      }
-    catch (...)
-      {
-        ACE_ERROR ((LM_ERROR,
-          ACE_TEXT ("QOS_XML_File_Handler::get_participant_qos - ")
-          ACE_TEXT ("Unexpected exception whilst parsing XML into IDL.\n")));
-        retcode = DDS::RETCODE_ERROR;
-      }
-
-    return retcode;
-  }
-
   void
-  QOS_XML_File_Handler::add_search_path (const ACE_TCHAR *environment,
-                                          const ACE_TCHAR *relpath)
+  QOS_XML_File_Handler::add_search_path(const ACE_TCHAR *environment,
+                                        const ACE_TCHAR *relpath)
   {
-    XML_Helper_type::XML_HELPER.get_resolver ().get_resolver ().add_path (environment, relpath);
+    XML_Helper_type::XML_HELPER.get_resolver().get_resolver().add_path(environment, relpath);
   }
 
 }
diff --git a/dds/DCPS/QOS_XML_Handler/XML_File_Intf.h b/dds/DCPS/QOS_XML_Handler/XML_File_Intf.h
index d09150290..707537eaa 100644
--- a/dds/DCPS/QOS_XML_Handler/XML_File_Intf.h
+++ b/dds/DCPS/QOS_XML_Handler/XML_File_Intf.h
@@ -4,6 +4,7 @@
  *
  *
  *  @author Marcel Smit (msmit@remedy.nl)
+ *  @author Danilo C. Zanella (dczanella@gmail.com)
  */
 //================================================================
 
@@ -16,8 +17,9 @@
 #endif /* ACE_LACKS_PRAGMA_ONCE */
 
 #include "dds_qos.hpp"
+#include "XML_Intf.h"
 #include "dds/DdsDcpsInfrastructureC.h"
-#include "dds/DCPS/QOS_XML_Handler/XML_QOS_Handler_Export.h"
+#include "XML_QOS_Handler_Export.h"
 
 namespace XML
 {
@@ -29,12 +31,13 @@ OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
 namespace OpenDDS {
 namespace DCPS {
 
-  class XML_QOS_Handler_Export QOS_XML_File_Handler
+  class XML_QOS_Handler_Export QOS_XML_File_Handler :
+    public QOS_XML_Handler
   {
   public:
-    QOS_XML_File_Handler (void);
+    QOS_XML_File_Handler(void);
 
-    ~QOS_XML_File_Handler (void);
+    ~QOS_XML_File_Handler(void);
 
     /**
      *
@@ -46,49 +49,9 @@ namespace DCPS {
      *
      */
     DDS::ReturnCode_t
-    init (const ACE_TCHAR * file);
+    init(const ACE_TCHAR * file);
 
 
-    //@{
-    /**
-     *
-     * These methods will search for the profileQos in
-     * profiles_, using the given profile_name.
-     * If found, these methods will invoke
-     * the corresponding method on the corresponding Handler
-     * class.
-     * These classes are available in the
-     * xxxQos_Handler.h files.
-     *
-     */
-    DDS::ReturnCode_t
-    get_datawriter_qos (::DDS::DataWriterQos& dw_qos,
-                        const char * profile_name,
-                        const char * topic_name);
-
-    DDS::ReturnCode_t
-    get_datareader_qos (::DDS::DataReaderQos& dr_qos,
-                        const char * profile_name,
-                        const char * topic_name);
-
-    DDS::ReturnCode_t
-    get_topic_qos (::DDS::TopicQos& tp_qos,
-                    const char * profile_name,
-                    const char * topic_name);
-
-    DDS::ReturnCode_t
-    get_publisher_qos (::DDS::PublisherQos& pub_qos,
-                        const char * profile_name);
-
-    DDS::ReturnCode_t
-    get_subscriber_qos (::DDS::SubscriberQos& sub_qos,
-                        const char * profile_name);
-
-    DDS::ReturnCode_t
-    get_participant_qos (::DDS::DomainParticipantQos& sub_qos,
-                          const char * profile_name);
-    //@}
-
     /**
      *
      * add_search_path will add a relative path to the XML
@@ -97,20 +60,12 @@ namespace DCPS {
      *
      */
     void
-    add_search_path (const ACE_TCHAR *environment,
-                      const ACE_TCHAR *relpath);
+    add_search_path(const ACE_TCHAR *environment,
+                    const ACE_TCHAR *relpath);
 
   private:
-    ::dds::qosProfile_seq profiles_;
     typedef XML::XML_Typedef XML_Helper_type;
 
-    /**
-     *
-     * Searches for the profile in the XML file, using the given
-     * profile name.
-     *
-     */
-    ::dds::qosProfile * get_profile (const char * profile_name);
   };
 }
 }
diff --git a/dds/DCPS/QOS_XML_Handler/XML_Intf.cpp b/dds/DCPS/QOS_XML_Handler/XML_Intf.cpp
new file mode 100644
index 000000000..0de74c8e4
--- /dev/null
+++ b/dds/DCPS/QOS_XML_Handler/XML_Intf.cpp
@@ -0,0 +1,391 @@
+
+#include "XML_Intf.h"
+#include "ace/XML_Utils/XML_Typedefs.h"
+#include "ace/XML_Utils/XMLSchema/id_map.hpp"
+
+#include "DataReaderQos_Handler.h"
+#include "DataWriterQos_Handler.h"
+#include "TopicQos_Handler.h"
+#include "PublisherQos_Handler.h"
+#include "SubscriberQos_Handler.h"
+#include "ParticipantQos_Handler.h"
+
+#include "dds/DCPS/debug.h"
+
+OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
+
+namespace OpenDDS {
+namespace DCPS {
+
+  QOS_XML_Handler::QOS_XML_Handler(void)
+  {
+  }
+
+  QOS_XML_Handler::~QOS_XML_Handler(void)
+  {
+  }
+
+  ::dds::qosProfile *
+  QOS_XML_Handler::get_profile(const ACE_TCHAR * profile_name)
+  {
+    if (ACE_OS::strlen(profile_name) == 0)
+    {
+      if (DCPS_debug_level > 7)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("(%P|%t) ERROR: QOS_XML_Handler::get_profile - ")
+          ACE_TEXT("No profile specified\n")));
+        return 0;
+      }
+    }
+
+    dds::qosProfile_seq::qos_profile_const_iterator it;
+    for (it = profiles_.begin_qos_profile();
+        it != profiles_.end_qos_profile();
+        ++it)
+      {
+        if (ACE_OS::strcmp((*it)->name().c_str(), profile_name) == 0)
+          {
+            if (DCPS_debug_level > 7)
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("QOS_XML_Handler::get_profile - ")
+                  ACE_TEXT("Found profile <%s>\n"),
+                  (*it)->name().c_str()));
+              }
+            return it->get();
+          }
+      }
+
+    if (OpenDDS::DCPS::DCPS_debug_level > 7)
+      {
+        ACE_ERROR ((LM_ERROR,
+          ACE_TEXT("(%P|%t) ERROR: QOS_XML_Handler::get_profile - ")
+          ACE_TEXT("Did not find profile <%s>\n"),
+          profile_name));
+      }
+
+    return 0;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::addQoSProfile(const dds::qosProfile & profile)
+  {
+    // get profile name  and check if it exists
+
+    const ACE_TCHAR* profileName = profile.name().c_str();
+    if (ACE_OS::strlen(profileName) == 0) {
+      if (DCPS_debug_level > 7)
+      {
+         ACE_ERROR((LM_ERROR,
+           ACE_TEXT("(%P|%t) ERROR: QOS_XML_Handler::addQoSProfile - ")
+           ACE_TEXT("No profile name specified\n")));
+      return DDS::RETCODE_ERROR;
+      }
+    }
+
+    // check if this profile name is already in the list
+    dds::qosProfile_seq::qos_profile_const_iterator it;
+    for (it = profiles_.begin_qos_profile();
+         it != profiles_.end_qos_profile();
+         ++it)
+    {
+      if (ACE_OS::strcmp((*it)->name().c_str(), profileName) == 0) {
+        if (DCPS_debug_level > 7)
+        {
+          ACE_ERROR((LM_ERROR,
+            ACE_TEXT("(%P|%t) ERROR: QOS_XML_Handler::addQoSProfile - ")
+            ACE_TEXT("Profile exists or profile name <%C> in use.\n"),
+            profileName));
+        }
+        return DDS::RETCODE_ERROR;
+      }
+    }
+
+    // append qos profile to list
+    dds::qosProfile_seq::qos_profile_value_type t(new dds::qosProfile(profile));
+    profiles_.add_qos_profile(t);
+    return DDS::RETCODE_OK;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::addQoSProfileSeq(const dds::qosProfile_seq & profiles)
+  {
+
+    dds::qosProfile_seq::qos_profile_const_iterator it;
+    for (it = profiles.begin_qos_profile();
+         it != profiles.end_qos_profile();
+         ++it)
+    {
+      dds::qosProfile qos(*(it->get()));
+      addQoSProfile(qos);
+    }
+
+    return DDS::RETCODE_OK;
+
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::delQoSProfile(const ACE_TCHAR * profileName)
+  {
+
+    if (ACE_OS::strlen(profileName) == 0)
+    {
+      if (DCPS_debug_level > 7)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("(%P|%t) ERROR: QOS_XML_Handler::delQoSProfile - ")
+          ACE_TEXT("No profile specified\n")));
+        return DDS::RETCODE_ERROR;
+      }
+    }
+
+    dds::qosProfile_seq::qos_profile_const_iterator it;
+    for (it = profiles_.begin_qos_profile();
+         it != profiles_.end_qos_profile();
+         ++it)
+    {
+      if (ACE_OS::strcmp((*it)->name().c_str(), profileName) == 0) {
+        profiles_.del_qos_profile(*it);
+        return DDS::RETCODE_OK;
+      }
+
+    }
+
+    if (DCPS_debug_level > 7)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("(%P|%t) ERROR: QOS_XML_Handler::delQoSProfile - ")
+        ACE_TEXT("Profile doesn't exists or wrong profile name.\n")));
+    }
+    return DDS::RETCODE_ERROR;
+  }
+
+  size_t QOS_XML_Handler::length() const
+  {
+     return profiles_.count_qos_profile();
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::get_datawriter_qos(::DDS::DataWriterQos& dw_qos,
+                                      const ACE_TCHAR * profile_name,
+                                      const ACE_TCHAR * topic_name)
+  {
+    ACE_UNUSED_ARG(topic_name);
+
+    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
+    try
+      {
+        ::dds::qosProfile * profile = this->get_profile(profile_name);
+        if (profile != 0)
+          {
+            DataWriterQos_Handler::get_datawriter_qos(dw_qos, profile);
+            retcode = ::DDS::RETCODE_OK;
+          }
+        else
+          retcode = DDS::RETCODE_BAD_PARAMETER;
+      }
+    catch (const CORBA::Exception &ex)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_datawriter_qos - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
+          ex._info().c_str()));
+        retcode = DDS::RETCODE_ERROR;
+      }
+    catch (...)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_datawriter_qos - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML into IDL.\n")));
+        retcode = DDS::RETCODE_ERROR;
+      }
+
+    return retcode;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::get_datareader_qos(::DDS::DataReaderQos& dr_qos,
+                                      const ACE_TCHAR * profile_name,
+                                      const ACE_TCHAR * topic_name)
+  {
+    ACE_UNUSED_ARG(topic_name);
+
+    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
+    try
+      {
+        ::dds::qosProfile * profile = this->get_profile(profile_name);
+        if (profile != 0)
+          {
+            DataReaderQos_Handler::get_datareader_qos(dr_qos, profile);
+            retcode = ::DDS::RETCODE_OK;
+          }
+        else
+          retcode = DDS::RETCODE_BAD_PARAMETER;
+      }
+    catch (const CORBA::Exception &ex)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_datareader_qos - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
+          ex._info().c_str()));
+        retcode = DDS::RETCODE_ERROR;
+      }
+    catch (...)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_datareader_qos - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML into IDL.\n")));
+        retcode = DDS::RETCODE_ERROR;
+      }
+
+    return retcode;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::get_topic_qos(::DDS::TopicQos& tp_qos,
+                                 const ACE_TCHAR * profile_name,
+                                 const ACE_TCHAR * topic_name)
+  {
+    ACE_UNUSED_ARG(topic_name);
+
+    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
+    try
+      {
+        ::dds::qosProfile * profile = this->get_profile(profile_name);
+        if (profile != 0)
+          {
+            TopicQos_Handler::get_topic_qos(tp_qos, profile);
+            retcode = ::DDS::RETCODE_OK;
+          }
+        else
+          retcode = DDS::RETCODE_BAD_PARAMETER;
+      }
+    catch (const CORBA::Exception &ex)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_topic_qos - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
+          ex._info().c_str()));
+        retcode = DDS::RETCODE_ERROR;
+      }
+    catch (...)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_topic_qos - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML into IDL.\n")));
+        retcode = DDS::RETCODE_ERROR;
+      }
+
+    return retcode;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::get_publisher_qos(::DDS::PublisherQos& pub_qos,
+                                     const ACE_TCHAR * profile_name)
+  {
+    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
+    try
+      {
+        ::dds::qosProfile * profile = this->get_profile(profile_name);
+        if (profile != 0)
+          {
+            PublisherQos_Handler::get_publisher_qos(pub_qos, profile);
+            retcode = ::DDS::RETCODE_OK;
+          }
+        else
+          retcode = DDS::RETCODE_BAD_PARAMETER;
+      }
+    catch (const CORBA::Exception &ex)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_publisher_qos - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
+          ex._info().c_str()));
+        retcode = DDS::RETCODE_ERROR;
+      }
+    catch (...)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_publisher_qos - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML into IDL.\n")));
+        retcode = DDS::RETCODE_ERROR;
+      }
+
+    return retcode;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::get_subscriber_qos(::DDS::SubscriberQos& sub_qos,
+                                      const ACE_TCHAR * profile_name)
+  {
+    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
+    try
+      {
+        ::dds::qosProfile * profile = this->get_profile(profile_name);
+        if (profile != 0)
+          {
+            SubscriberQos_Handler::get_subscriber_qos(sub_qos, profile);
+            retcode = ::DDS::RETCODE_OK;
+          }
+        else
+          retcode = DDS::RETCODE_BAD_PARAMETER;
+      }
+    catch (const CORBA::Exception &ex)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_subscriber_qos - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
+          ex._info().c_str()));
+        retcode = DDS::RETCODE_ERROR;
+      }
+    catch (...)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_subscriber_qos - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML into IDL.\n")));
+        retcode = DDS::RETCODE_ERROR;
+      }
+
+    return retcode;
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_Handler::get_participant_qos(::DDS::DomainParticipantQos& sub_qos,
+                                       const ACE_TCHAR * profile_name)
+  {
+    DDS::ReturnCode_t retcode = DDS::RETCODE_ERROR;
+    try
+      {
+        ::dds::qosProfile * profile = this->get_profile(profile_name);
+        if (profile != 0)
+          {
+            ParticipantQos_Handler::get_participant_qos(sub_qos, profile);
+            retcode = ::DDS::RETCODE_OK;
+          }
+        else
+          retcode = DDS::RETCODE_BAD_PARAMETER;
+      }
+    catch (const CORBA::Exception &ex)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_participant_qos - ")
+          ACE_TEXT("Caught CORBA exception whilst parsing XML into IDL: %C\n"),
+          ex._info().c_str()));
+        retcode = DDS::RETCODE_ERROR;
+      }
+    catch (...)
+      {
+        ACE_ERROR((LM_ERROR,
+          ACE_TEXT("QOS_XML_Handler::get_participant_qos - ")
+          ACE_TEXT("Unexpected exception whilst parsing XML into IDL.\n")));
+        retcode = DDS::RETCODE_ERROR;
+      }
+
+    return retcode;
+  }
+
+}
+}
+
+OPENDDS_END_VERSIONED_NAMESPACE_DECL
diff --git a/dds/DCPS/QOS_XML_Handler/XML_Intf.h b/dds/DCPS/QOS_XML_Handler/XML_Intf.h
new file mode 100644
index 000000000..c10f90482
--- /dev/null
+++ b/dds/DCPS/QOS_XML_Handler/XML_Intf.h
@@ -0,0 +1,128 @@
+//==============================================================
+/**
+ *  @file  XML_Intf.h
+ *
+ *
+ *  @author Danilo C. Zanella (dczanella@gmail.com)
+ */
+//================================================================
+
+#ifndef DCPS_CONFIG_XML_INTF_H
+#define DCPS_CONFIG_XML_INTF_H
+#include /**/ "ace/pre.h"
+
+#if !defined (ACE_LACKS_PRAGMA_ONCE)
+# pragma once
+#endif /* ACE_LACKS_PRAGMA_ONCE */
+
+#include "dds_qos.hpp"
+#include "dds/DdsDcpsInfrastructureC.h"
+#include "XML_QOS_Handler_Export.h"
+
+OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
+
+namespace OpenDDS {
+namespace DCPS {
+
+  class XML_QOS_Handler_Export QOS_XML_Handler
+  {
+  public:
+    QOS_XML_Handler(void);
+
+    ~QOS_XML_Handler(void);
+
+    //@{
+    /**
+     *
+     * These methods will search for the profileQos in
+     * profiles_, using the given profile_name.
+     * If found, these methods will invoke
+     * the corresponding method on the corresponding Handler
+     * class.
+     * These classes are available in the
+     * xxxQos_Handler.h files.
+     *
+     */
+    DDS::ReturnCode_t
+    get_datawriter_qos(::DDS::DataWriterQos& dw_qos,
+                       const ACE_TCHAR * profile_name,
+                       const ACE_TCHAR * topic_name);
+
+    DDS::ReturnCode_t
+    get_datareader_qos(::DDS::DataReaderQos& dr_qos,
+                       const ACE_TCHAR * profile_name,
+                       const ACE_TCHAR * topic_name);
+
+    DDS::ReturnCode_t
+    get_topic_qos(::DDS::TopicQos& tp_qos,
+                  const ACE_TCHAR * profile_name,
+                  const ACE_TCHAR * topic_name);
+
+    DDS::ReturnCode_t
+    get_publisher_qos(::DDS::PublisherQos& pub_qos,
+                      const ACE_TCHAR * profile_name);
+
+    DDS::ReturnCode_t
+    get_subscriber_qos(::DDS::SubscriberQos& sub_qos,
+                       const ACE_TCHAR * profile_name);
+
+    DDS::ReturnCode_t
+    get_participant_qos(::DDS::DomainParticipantQos& sub_qos,
+                        const ACE_TCHAR * profile_name);
+
+    /**
+     *  Add qos profile to sequence
+     */
+    DDS::ReturnCode_t
+    addQoSProfile(const dds::qosProfile & profile);
+
+    /**
+     *  Add qos profiles to sequence
+     */
+    DDS::ReturnCode_t
+    addQoSProfileSeq(const dds::qosProfile_seq & profiles);
+
+    /**
+     *  Remove  qos profile to sequence
+     */
+    DDS::ReturnCode_t
+    delQoSProfile(const ACE_TCHAR * profileName);
+
+    /**
+     *  Get number of profiles in sequence
+     */
+    size_t length() const;
+
+    /**
+    * Get profile by name
+    */
+    ::dds::qosProfile getProfile(const ACE_TCHAR * profileName) {
+      return *get_profile (profileName);
+    }
+
+    /**
+     *  get profiles sequence
+     */
+    const ::dds::qosProfile_seq& get() {
+      return profiles_;
+    }
+
+  protected:
+    ::dds::qosProfile_seq profiles_;
+
+    /**
+     *
+     * Searches for the profile in the XML file, using the given
+     * profile name.
+     *
+     */
+    ::dds::qosProfile * get_profile(const ACE_TCHAR * profile_name);
+  };
+}
+}
+
+OPENDDS_END_VERSIONED_NAMESPACE_DECL
+
+#include /**/ "ace/post.h"
+
+#endif /* DCPS_CONFIG_XML_INTF_H */
diff --git a/dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.cpp b/dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.cpp
new file mode 100644
index 000000000..5e15ea6fd
--- /dev/null
+++ b/dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.cpp
@@ -0,0 +1,257 @@
+#include "XML_MemBuf_Intf.h"
+#include "xercesc/util/XercesDefs.hpp"
+#include "xercesc/framework/MemBufInputSource.hpp"
+#include "xercesc/parsers/XercesDOMParser.hpp"
+#include "xercesc/sax/SAXParseException.hpp"
+#include "xercesc/util/TransService.hpp"
+#include "ace/XML_Utils/XML_Typedefs.h"
+#include "ace/XML_Utils/XML_Schema_Resolver.h"
+#include "ace/XML_Utils/XML_Error_Handler.h"
+
+
+#include "dds/DCPS/debug.h"
+
+OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
+
+namespace OpenDDS {
+namespace DCPS {
+
+  QOS_XML_MemBuf_Handler::QOS_XML_MemBuf_Handler(void) :
+    QOS_XML_Handler(),
+    res_(new XML::XML_Schema_Resolver<XML::Environment_Resolver>()),
+    eh_(new XML::XML_Error_Handler()),
+    parser_(0),
+    finalDoc_(0)
+  {
+    try
+    {
+      // Call Initialize if not already called
+      XMLPlatformUtils::Initialize();
+
+      ////////////////
+      // Create parser
+      parser_ =  new XercesDOMParser();
+
+      // Create a DomImplementation
+      XMLCh* xmlver = XMLString::transcode("XML 1.0");
+      DOMImplementation * domImpl = DOMImplementationRegistry::getDOMImplementation(xmlver);
+      XMLString::release(&xmlver);
+
+      // Create a temporary document with a generic element
+      // it shall be replaced in future with final version
+      XMLCh* namespaceURI = XMLString::transcode("");
+       XMLCh* qualifiedName = XMLString::transcode("temp");
+      finalDoc_ = domImpl->createDocument(namespaceURI, qualifiedName,0);
+      XMLString::release(&namespaceURI);
+      XMLString::release(&qualifiedName);
+
+    } catch (const XMLException& toCatch) {
+
+      char* message = XMLString::transcode(toCatch.getMessage());
+      ACE_ERROR ((LM_ERROR,
+        ACE_TEXT ("QOS_XML_MemBuf_Handler::QOS_XML_MemBuf_Handler - ")
+        ACE_TEXT ("Error during XML initialization! :\n<%C>\n"),
+        message));
+      XMLString::release(&message);
+    }
+  }
+
+  QOS_XML_MemBuf_Handler::~QOS_XML_MemBuf_Handler(void)
+  {
+    if (finalDoc_ != 0)
+      finalDoc_->release();
+    delete parser_;
+    delete res_;
+    delete eh_;
+
+    XMLPlatformUtils::Terminate();
+  }
+
+  DDS::ReturnCode_t
+  QOS_XML_MemBuf_Handler::init(const ACE_TCHAR * membuf)
+  {
+    DDS::ReturnCode_t retcode = DDS::RETCODE_OK;
+    try
+    {
+      // Create a InputSource to be used in parser with XML string
+      XMLCh * conv = XMLString::transcode(ACE_TEXT_ALWAYS_CHAR (membuf));
+      TranscodeToStr xmlTranscoded(conv,"utf-8");
+      XMLString::release(&conv);
+      MemBufInputSource xmlBuf(xmlTranscoded.str(), xmlTranscoded.length() ,"xml (in memory)");
+
+      ///////////////////
+      // Configure Parser
+      //
+      // Perform Namespace processing.
+      parser_->setDoNamespaces (true);
+      // Discard comment nodes in the document
+      parser_->setCreateCommentNodes (false);
+      // Disable datatype normalization. The XML 1.0 attribute value
+      // normalization always occurs though.
+      // parser_->setFeature (XMLUni::fgDOMDatatypeNormalization, true);
+
+      // Do not create EntityReference nodes in the DOM tree. No
+      // EntityReference nodes will be created, only the nodes
+      // corresponding to their fully expanded sustitution text will be
+      // created.
+      parser_->setCreateEntityReferenceNodes (false);
+      // Perform Validation
+      parser_->setValidationScheme (xercesc::AbstractDOMParser::Val_Always);
+      // Do not include ignorable whitespace in the DOM tree.
+      parser_->setIncludeIgnorableWhitespace (false);
+      // Enable the parser_'s schema support.
+      parser_->setDoSchema (true);
+      // Enable full schema constraint checking, including checking which
+      // may be time-consuming or memory intensive. Currently, particle
+      // unique attribution constraint checking and particle derivation
+      // restriction checking are controlled by this option.
+      parser_->setValidationSchemaFullChecking (true);
+      // The parser_ will treat validation error as fatal and will exit.
+      parser_->setValidationConstraintFatal (true);
+
+      // Set resolver using auxiliary XML_Schema_Resolver
+      parser_->setEntityResolver(res_);
+
+      // Set XML Error handler
+      parser_->setErrorHandler(eh_);
+
+      // Parsing buffer
+      try {
+        parser_->parse(xmlBuf);
+      }
+      catch (const SAXParseException& toCatch) {
+        char* message = XMLString::transcode(toCatch.getMessage());
+        ACE_ERROR ((LM_ERROR,
+          ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+          ACE_TEXT ("Exception message is: <%C>\n"),
+          message));
+        XMLString::release(&message);
+        return DDS::RETCODE_ERROR;
+      }
+      catch (const XMLException& toCatch) {
+        char* message = XMLString::transcode(toCatch.getMessage());
+        ACE_ERROR ((LM_ERROR,
+          ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+          ACE_TEXT ("Exception message is: <%C>\n"),
+          message));
+        XMLString::release(&message);
+        return DDS::RETCODE_ERROR;
+      }
+      catch (const DOMException& toCatch) {
+        char* message = XMLString::transcode(toCatch.getMessage());
+        ACE_ERROR ((LM_ERROR,
+          ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+          ACE_TEXT ("Exception message is: <%C>\n"),
+          message));
+        XMLString::release(&message);
+        return DDS::RETCODE_ERROR;
+      }
+      catch (...) {
+        ACE_ERROR ((LM_ERROR,
+          ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+          ACE_TEXT ("Unexpected exception\n")
+          ));
+        return DDS::RETCODE_ERROR;
+      }
+
+      DOMDocument * initialDoc = parser_->getDocument();
+      if (initialDoc == 0)
+      {
+        if (DCPS_debug_level > 1)
+        {
+          ACE_ERROR ((LM_ERROR,
+            ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+            ACE_TEXT ("Failed to parse string\n")
+            ));
+        }
+        return DDS::RETCODE_ERROR;
+      }
+
+      // Find "dds" node using the opendds namespace
+      XMLCh* ns = XMLString::transcode("http://www.omg.org/dds");
+      XMLCh* ddstag = XMLString::transcode("dds");
+
+      DOMNodeList * ddsNodeList = initialDoc->getElementsByTagNameNS(ns, ddstag);
+      XMLString::release(&ns);
+      XMLString::release(&ddstag);
+
+      // Check if it could find tag and namespace
+      if (ddsNodeList->getLength() == 0)
+      {
+        if (DCPS_debug_level > 1)
+          {
+            ACE_ERROR ((LM_ERROR,
+              ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+              ACE_TEXT ("Could not find tag(dds) in namespace(http://www.omg.org/dds)\n")
+              ));
+          }
+        return DDS::RETCODE_ERROR;
+      }
+
+      // Get the first node. It is expected to have only one
+      DOMNode * ddsNode = ddsNodeList->item(0);
+      if (DCPS_debug_level > 1)
+      {
+        char* message = XMLString::transcode(ddsNode->getNodeName());
+        ACE_DEBUG ((LM_DEBUG,
+          ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+          ACE_TEXT ("Node name: <%C>\n"),
+          message));
+        XMLString::release(&message);
+      }
+
+      DOMNode * clone = finalDoc_->importNode(ddsNode, true);
+
+      // Check if import was successful
+      if (clone == 0)
+      {
+        if (DCPS_debug_level > 1)
+        {
+          ACE_ERROR ((LM_ERROR,
+            ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+            ACE_TEXT ("Failed to get pointer of imported node\n")
+            ));
+        }
+        return DDS::RETCODE_ERROR;
+      }
+      // Replace root element by the cloned one. Thus the root element
+      // shall be "dds" as required by dds::reader::dds function
+      finalDoc_->replaceChild(clone,finalDoc_->getDocumentElement());
+
+      ID_Map::TSS_ID_Map* TSS_ID_Map (ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance());
+      (*TSS_ID_Map)->reset ();
+
+      profiles_ = dds::reader::dds(finalDoc_);
+
+    }
+    catch (const CORBA::Exception &ex)
+    {
+      ACE_ERROR ((LM_ERROR,
+        ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+        ACE_TEXT ("Caught CORBA exception whilst parsing XML\n"),
+        ex._info ().c_str ()));
+      retcode = DDS::RETCODE_ERROR;
+    }
+    catch (...)
+    {
+      ACE_ERROR ((LM_ERROR,
+        ACE_TEXT ("QOS_XML_MemBuf_Handler::init - ")
+        ACE_TEXT ("Unexpected exception whilst parsing XML.\n")
+        ));
+      retcode = DDS::RETCODE_ERROR;
+    }
+    return retcode;
+
+  }
+
+  void
+  QOS_XML_MemBuf_Handler::add_search_path(const ACE_TCHAR *environment,
+                                          const ACE_TCHAR *relpath)
+  {
+    res_->get_resolver().add_path(environment,relpath);
+  }
+
+}
+}
+
+OPENDDS_END_VERSIONED_NAMESPACE_DECL
diff --git a/dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.h b/dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.h
new file mode 100644
index 000000000..4166009e3
--- /dev/null
+++ b/dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.h
@@ -0,0 +1,94 @@
+//==============================================================
+/**
+ *  @file  XML_MemBuf_Intf.h
+ *
+ *
+ *  @author Danilo C. Zanella (dczanella@gmail.com)
+ */
+//================================================================
+
+#ifndef OPENDDS_DCPS_QOS_XML_HANDLER_XML_MEMBUF_INTF_H
+#define OPENDDS_DCPS_QOS_XML_HANDLER_XML_MEMBUF_INTF_H
+#include /**/ "ace/pre.h"
+
+#if !defined (ACE_LACKS_PRAGMA_ONCE)
+# pragma once
+#endif /* ACE_LACKS_PRAGMA_ONCE */
+
+#include "dds_qos.hpp"
+#include "XML_Intf.h"
+#include "dds/DdsDcpsInfrastructureC.h"
+#include "XML_QOS_Handler_Export.h"
+
+namespace XML
+{
+  class Environment_Resolver;
+  template <typename Resolver>
+  class XML_Schema_Resolver;
+  class XML_Error_Handler;
+}
+
+XERCES_CPP_NAMESPACE_BEGIN
+  class XercesDOMParser;
+  class DOMDocument;
+XERCES_CPP_NAMESPACE_END
+
+OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
+
+namespace OpenDDS {
+namespace DCPS {
+
+  class XML_QOS_Handler_Export QOS_XML_MemBuf_Handler :
+    public QOS_XML_Handler
+  {
+  public:
+    QOS_XML_MemBuf_Handler(void);
+
+    ~QOS_XML_MemBuf_Handler(void);
+
+    /**
+     *
+     * init
+     *
+     * The init method will open the file and will validate
+     * it against the schema. It returns RETCODE_ERROR
+     * when any error occurs during parsing
+     *
+     */
+    DDS::ReturnCode_t
+    init(const ACE_TCHAR * membuf);
+
+    /**
+     *
+     * add_search_path will add a relative path to the XML
+     * parsing library. The XML parsing library will use
+     * this path to search for the schema
+     *
+     */
+    void
+    add_search_path(const ACE_TCHAR *environment,
+                    const ACE_TCHAR *relpath);
+
+  private:
+    // Schema resolver
+    XML::XML_Schema_Resolver<XML::Environment_Resolver> * res_;
+
+    // Error handler
+    XML::XML_Error_Handler * eh_;
+
+    // Parser
+    XERCES_CPP_NAMESPACE::XercesDOMParser * parser_;
+
+    // Final DOMDocument that should be passed to
+    // dds::reader::dds method
+    XERCES_CPP_NAMESPACE::DOMDocument * finalDoc_;
+
+  };
+}
+}
+
+OPENDDS_END_VERSIONED_NAMESPACE_DECL
+
+#include /**/ "ace/post.h"
+
+#endif /* DCPS_CONFIG_XML_MEMBUF_INTF_H */
diff --git a/dds/DCPS/QOS_XML_Handler/dds_qos.cpp b/dds/DCPS/QOS_XML_Handler/dds_qos.cpp
index 6d766fa06..b840616f1 100644
--- a/dds/DCPS/QOS_XML_Handler/dds_qos.cpp
+++ b/dds/DCPS/QOS_XML_Handler/dds_qos.cpp
@@ -5012,6 +5012,12 @@ namespace dds
     qos_profile_.push_back (e);
   }
 
+  void qosProfile_seq::
+  del_qos_profile(qosProfile_seq::qos_profile_value_type const& e)
+  {
+    qos_profile_.remove (e);
+  }
+
   size_t qosProfile_seq::
   count_qos_profile(void) const
   {
@@ -6671,4 +6677,3 @@ namespace dds
     }
   }
 }
-
diff --git a/dds/DCPS/QOS_XML_Handler/dds_qos.hpp b/dds/DCPS/QOS_XML_Handler/dds_qos.hpp
index 98fd9347a..7307a08f3 100644
--- a/dds/DCPS/QOS_XML_Handler/dds_qos.hpp
+++ b/dds/DCPS/QOS_XML_Handler/dds_qos.hpp
@@ -2018,6 +2018,7 @@ namespace dds
     qos_profile_const_iterator begin_qos_profile () const;
     qos_profile_const_iterator end_qos_profile () const;
     void add_qos_profile (qos_profile_value_type const&);
+    void del_qos_profile (qos_profile_value_type const&);
     size_t count_qos_profile () const;
 
     protected:
diff --git a/dds/DCPS/QOS_XML_Handler/qos_xml_handler.mpc b/dds/DCPS/QOS_XML_Handler/qos_xml_handler.mpc
index 9e5e5f38a..41b354dfa 100644
--- a/dds/DCPS/QOS_XML_Handler/qos_xml_handler.mpc
+++ b/dds/DCPS/QOS_XML_Handler/qos_xml_handler.mpc
@@ -32,7 +32,9 @@ project(OpenDDS_QOS_XML_XSC_Handler): install, ace_xml_utils, dcpslib {
 
   Source_Files {
     dds_qos.cpp
+    XML_Intf.cpp
     XML_File_Intf.cpp
+    XML_MemBuf_Intf.cpp
     QOS_XML_Loader.cpp
     DataWriterQos_Handler.cpp
     DataReaderQos_Handler.cpp
@@ -45,6 +47,9 @@ project(OpenDDS_QOS_XML_XSC_Handler): install, ace_xml_utils, dcpslib {
 
   Header_Files {
     XML_QOS_Handler_Export.h
+    XML_Intf.h
+    XML_File_Intf.h
+    XML_MemBuf_Intf.h
     dds_qos.hpp
     QOS_Common.h
     DataWriterQos_Handler.h
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/.gitignore b/tests/DCPS/QoS_XML/dumpMemBuf/.gitignore
new file mode 100644
index 000000000..3e045d698
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/.gitignore
@@ -0,0 +1 @@
+/qos_dump
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/append2test.xml b/tests/DCPS/QoS_XML/dumpMemBuf/append2test.xml
new file mode 100644
index 000000000..3da1e48a4
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/append2test.xml
@@ -0,0 +1,315 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<tst:test xmlns:tst="urn:internal:test:1.0"
+          xmlns="http://www.omg.org/dds"
+          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+          xsi:schemaLocation="urn:internal:test:1.0 test.xsd">
+  <dds>
+    <qos_profile name="TestA">
+      <datareader_qos>
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+      </datareader_qos>
+    </qos_profile>
+    <qos_profile name="TestB">
+      <datawriter_qos>
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+      </datawriter_qos>
+    </qos_profile>
+    <qos_profile name="TestC">
+      <subscriber_qos>
+        <partition>
+          <name>
+            <element>DAN</element>
+            <element>ZAN</element>
+          </name>
+        </partition>
+      </subscriber_qos>
+    </qos_profile>
+    <!-- repeated profile name in text.xml-->
+    <qos_profile name="TestProfile">
+      <publisher_qos>
+        <presentation>
+          <access_scope>INSTANCE_PRESENTATION_QOS</access_scope>
+          <coherent_access>false</coherent_access>
+          <ordered_access>false</ordered_access>
+        </presentation>
+      </publisher_qos>
+    </qos_profile>
+    <!-- For test purposes-->
+    <qos_profile name="TestProfile2">
+      <datareader_qos>
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+        <deadline>
+          <period>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </period>
+        </deadline>
+        <latency_budget>
+          <duration>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </duration>
+        </latency_budget>
+        <liveliness>
+          <kind>AUTOMATIC_LIVELINESS_QOS</kind>
+          <lease_duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </lease_duration>
+        </liveliness>
+        <reliability>
+          <kind>BEST_EFFORT_RELIABILITY_QOS</kind>
+          <max_blocking_time>
+            <sec>0</sec>
+            <nanosec>100000000</nanosec>
+          </max_blocking_time>
+        </reliability>
+        <destination_order>
+          <kind>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</kind>
+        </destination_order>
+        <history>
+          <kind>KEEP_LAST_HISTORY_QOS</kind>
+          <depth>1</depth>
+        </history>
+        <resource_limits>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </resource_limits>
+        <!--user_data>
+          <value></value>
+        </user_data-->
+        <ownership>
+          <kind>SHARED_OWNERSHIP_QOS</kind>
+        </ownership>
+        <time_based_filter>
+          <minimum_separation>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </minimum_separation>
+        </time_based_filter>
+        <reader_data_lifecycle>
+          <autopurge_nowriter_samples_delay>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </autopurge_nowriter_samples_delay>
+          <autopurge_disposed_samples_delay>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </autopurge_disposed_samples_delay>
+        </reader_data_lifecycle>
+      </datareader_qos>
+      <datawriter_qos>
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+        <durability_service>
+          <service_cleanup_delay>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </service_cleanup_delay>
+          <history_kind>KEEP_LAST_HISTORY_QOS</history_kind>
+          <history_depth>1</history_depth>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </durability_service>
+        <deadline>
+          <period>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </period>
+        </deadline>
+        <latency_budget>
+          <duration>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </duration>
+        </latency_budget>
+        <liveliness>
+          <kind>AUTOMATIC_LIVELINESS_QOS</kind>
+          <lease_duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </lease_duration>
+        </liveliness>
+        <reliability>
+          <kind>RELIABLE_RELIABILITY_QOS</kind>
+          <max_blocking_time>
+            <sec>0</sec>
+            <nanosec>100000000</nanosec>
+          </max_blocking_time>
+        </reliability>
+        <destination_order>
+          <kind>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</kind>
+        </destination_order>
+        <history>
+          <kind>KEEP_ALL_HISTORY_QOS</kind>
+          <depth>5</depth>
+        </history>
+        <resource_limits>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </resource_limits>
+        <transport_priority>
+          <value>0</value>
+        </transport_priority>
+        <lifespan>
+          <duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </duration>
+        </lifespan>
+        <!--user_data>
+          <value></value>
+        </user_data-->
+        <ownership>
+          <kind>SHARED_OWNERSHIP_QOS</kind>
+        </ownership>
+        <ownership_strength>
+          <value>0</value>
+        </ownership_strength>
+        <writer_data_lifecycle>
+          <autodispose_unregistered_instances>true</autodispose_unregistered_instances>
+        </writer_data_lifecycle>
+      </datawriter_qos>
+      <domainparticipant_qos>
+        <!--user_data>
+          <value></value>
+        </user_data-->
+        <entity_factory>
+          <autoenable_created_entities>true</autoenable_created_entities>
+        </entity_factory>
+      </domainparticipant_qos>
+      <subscriber_qos>
+        <presentation>
+          <access_scope>INSTANCE_PRESENTATION_QOS</access_scope>
+          <coherent_access>false</coherent_access>
+          <ordered_access>false</ordered_access>
+        </presentation>
+        <partition>
+          <name>
+            <element>ABC</element>
+            <element>DEF</element>
+            <element>GHI</element>
+            <element>JKL</element>
+            <element>MNO</element>
+            <element>PQR</element>
+            <element>STU</element>
+            <element>VW</element>
+            <element>XYZ</element>
+          </name>
+        </partition>
+        <!--group_data>
+          <value></value>
+        </group_data-->
+        <entity_factory>
+          <autoenable_created_entities>true</autoenable_created_entities>
+        </entity_factory>
+      </subscriber_qos>
+      <publisher_qos>
+        <presentation>
+          <access_scope>INSTANCE_PRESENTATION_QOS</access_scope>
+          <coherent_access>false</coherent_access>
+          <ordered_access>false</ordered_access>
+        </presentation>
+        <partition>
+          <name>
+            <element>XYZ</element>
+            <element>VW</element>
+            <element>STU</element>
+            <element>PQR</element>
+            <element>MNO</element>
+            <element>JKL</element>
+            <element>GHI</element>
+            <element>DEF</element>
+            <element>ABC</element>
+          </name>
+        </partition>
+        <!--group_data>
+          <value></value>
+        </group_data-->
+        <entity_factory>
+          <autoenable_created_entities>true</autoenable_created_entities>
+        </entity_factory>
+      </publisher_qos>
+      <topic_qos>
+        <!--topic_data>
+          <value></value>
+        </topic_data-->
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+        <durability_service>
+          <service_cleanup_delay>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </service_cleanup_delay>
+          <history_kind>KEEP_LAST_HISTORY_QOS</history_kind>
+          <history_depth>1</history_depth>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </durability_service>
+        <deadline>
+          <period>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </period>
+        </deadline>
+        <latency_budget>
+          <duration>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </duration>
+        </latency_budget>
+        <liveliness>
+          <kind>AUTOMATIC_LIVELINESS_QOS</kind>
+          <lease_duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </lease_duration>
+        </liveliness>
+        <reliability>
+          <kind>BEST_EFFORT_RELIABILITY_QOS</kind>
+          <max_blocking_time>
+            <sec>0</sec>
+            <nanosec>100000000</nanosec>
+          </max_blocking_time>
+        </reliability>
+        <destination_order>
+          <kind>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</kind>
+        </destination_order>
+        <history>
+          <kind>KEEP_LAST_HISTORY_QOS</kind>
+          <depth>1</depth>
+        </history>
+        <resource_limits>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </resource_limits>
+        <transport_priority>
+          <value>0</value>
+        </transport_priority>
+        <lifespan>
+          <duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </duration>
+        </lifespan>
+        <ownership>
+          <kind>SHARED_OWNERSHIP_QOS</kind>
+        </ownership>
+      </topic_qos>
+    </qos_profile>
+
+  </dds>
+</tst:test>
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/qos_dumpMemBuf.cpp b/tests/DCPS/QoS_XML/dumpMemBuf/qos_dumpMemBuf.cpp
new file mode 100644
index 000000000..ed7173cc8
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/qos_dumpMemBuf.cpp
@@ -0,0 +1,229 @@
+#include <fstream>
+#include <streambuf>
+#include "dds/DCPS/QOS_XML_Handler/XML_MemBuf_Intf.h"
+#include "dds/DdsDcpsC.h"
+#include "dds/DCPS/debug.h"
+
+int parseXML(const char* fileName,
+            const ACE_TCHAR* profileName,
+            const ACE_TCHAR* topicName,
+            OpenDDS::DCPS::QOS_XML_MemBuf_Handler& xml_membuf)
+{
+  int retval = 0;
+
+  try
+  {
+
+    // read file and create string
+    std::ifstream ifs(fileName);
+    std::stringstream buffer;
+    buffer << ifs.rdbuf();
+
+    // Add env variable and path to search schemas
+    xml_membuf.add_search_path(ACE_TEXT("DDS_ROOT"),ACE_TEXT("/docs/schema/"));
+    // initialize and parse XML
+    DDS::ReturnCode_t const retcode = xml_membuf.init(ACE_TEXT_CHAR_TO_TCHAR (buffer.str().c_str()));
+
+    if (retcode == DDS::RETCODE_OK)
+    {
+      DDS::ReturnCode_t retcode_qos;
+      ::DDS::DataWriterQos dw_qos;
+      retcode_qos = xml_membuf.get_datawriter_qos (
+          dw_qos,
+          profileName,
+          topicName);
+      if (retcode_qos != DDS::RETCODE_OK)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_datawriter_qos return an error. Retcode <%d>\n",
+              fileName, retcode_qos));
+        ++retval;
+      }
+
+      if (dw_qos.history.kind != ::DDS::KEEP_ALL_HISTORY_QOS)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_datawriter_qos return an invalid history kind.\n",
+              fileName));
+        ++retval;
+      }
+      if (dw_qos.history.depth != 5)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_datawriter_qos return an invalid history depth.\n",
+              fileName));
+        ++retval;
+      }
+
+      ::DDS::DataReaderQos dr_qos;
+      retcode_qos = xml_membuf.get_datareader_qos (
+          dr_qos,
+          profileName,
+          topicName);
+      if (retcode_qos != DDS::RETCODE_OK)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_datareader_qos return an error. Retcode <%d>\n",
+              fileName, retcode_qos));
+        ++retval;
+      }
+
+      ::DDS::TopicQos tp_qos;
+      retcode_qos = xml_membuf.get_topic_qos (
+          tp_qos,
+          profileName,
+          topicName);
+      if (retcode_qos != DDS::RETCODE_OK)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_topic_qos return an error. Retcode <%d>\n",
+              fileName, retcode_qos));
+        ++retval;
+      }
+
+      ::DDS::PublisherQos pub_qos;
+      retcode_qos = xml_membuf.get_publisher_qos (
+          pub_qos,
+          profileName);
+      if (retcode_qos != DDS::RETCODE_OK)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_publisher_qos return an error. Retcode <%d>\n",
+              fileName, retcode_qos));
+        ++retval;
+      }
+
+      ::DDS::SubscriberQos sub_qos;
+      retcode_qos = xml_membuf.get_subscriber_qos (
+          sub_qos,
+          profileName);
+      if (retcode_qos != DDS::RETCODE_OK)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_subscriber_qos return an error. Retcode <%d>\n",
+              fileName, retcode_qos));
+        ++retval;
+      }
+
+      ::DDS::DomainParticipantQos dp_qos;
+      retcode_qos = xml_membuf.get_participant_qos (
+          dp_qos,
+          profileName);
+      if (retcode_qos != DDS::RETCODE_OK)
+      {
+        ACE_ERROR ((LM_ERROR, "PARSEXML - "
+              "%s : get_participant_qos return an error. Retcode <%d>\n",
+              fileName, retcode_qos));
+        ++retval;
+      }
+    }
+    else
+    {
+      ACE_ERROR ((LM_ERROR, "Error processing file %s - Init return an error. Retcode <%d>\n",
+            fileName, retcode));
+      ++retval;
+    }
+
+  }
+  catch (const CORBA::Exception& ex)
+  {
+    ex._tao_print_exception ("QOS_Dump::main\n");
+    return 1;
+  }
+  catch (...)
+  {
+    ACE_ERROR ((LM_ERROR, ACE_TEXT ("Unexpected exception\n")));
+    return 1;
+  }
+
+  return retval;
+};
+
+int ACE_TMAIN (int, ACE_TCHAR *[])
+{
+  int retval = 0;
+  OpenDDS::DCPS::QOS_XML_MemBuf_Handler xml1;
+  OpenDDS::DCPS::QOS_XML_MemBuf_Handler xml2;
+
+  // Test first file
+  // File name and profile name in respective file
+  // topic name in respective profile name
+  {
+    retval += parseXML("test.xml",
+                      ACE_TEXT("TestProfile"),
+                      ACE_TEXT("TopicName"),
+                      xml1);
+    if (retval > 0)
+      return retval;
+  }
+  // Test second file
+  // File name and profile name in respective file
+  // topic name in respective profile name
+  {
+    retval += parseXML("append2test.xml",
+                      ACE_TEXT("TestProfile2"),
+                      ACE_TEXT("TopicName"),
+                      xml2);
+    if (retval > 0)
+      return retval;
+  }
+  // Test xml_membuf operations
+  // append a profile
+  {
+    const ACE_TCHAR* profileName = ACE_TEXT("TestA");
+    dds::qosProfile profile = xml2.getProfile(profileName);
+    DDS::ReturnCode_t retcode;
+    retcode = xml1.addQoSProfile(profile);
+    if (retcode != DDS::RETCODE_OK)
+    {
+      ACE_ERROR ((LM_ERROR, "MAIN - "
+            "Cannot append profile name <%C>. Retcode <%d>\n",
+            profileName, retcode));
+      return ++retval;
+    }
+    // Check if it was inserted
+    dds::qosProfile testA = xml2.getProfile(profileName);
+    if (ACE_OS::strcmp(testA.name().c_str(),profileName) != 0)
+    {
+      ACE_ERROR ((LM_ERROR, "MAIN - "
+            "Cannot get last profile name <%C> inserted. Retcode <%d>\n",
+            profileName, retcode));
+      return ++retval;
+    }
+
+    // Remove profile
+    retcode = xml1.delQoSProfile(profileName);
+    if (retcode != DDS::RETCODE_OK)
+    {
+      ACE_ERROR ((LM_ERROR, "MAIN - "
+            "Cannot remove profile name <%C>. Retcode <%d>\n",
+            profileName, retcode));
+      return ++retval;
+    }
+  }
+  // append existing profile name
+  {
+    const ACE_TCHAR* profileName = ACE_TEXT("TestProfile");
+    dds::qosProfile profile = xml2.getProfile(profileName);
+    DDS::ReturnCode_t retcode = xml1.addQoSProfile(profile);
+    if (retcode == DDS::RETCODE_OK)
+    {
+      ACE_ERROR ((LM_ERROR, "MAIN - "
+            "Unexpected insertion of profile name <%C>.\n",
+            profileName));
+      return ++retval;
+    }
+  }
+  // append list of profiles
+  {
+    const dds::qosProfile_seq& profiles = xml2.get();
+    DDS::ReturnCode_t retcode = xml1.addQoSProfileSeq(profiles);
+    if (retcode != DDS::RETCODE_OK)
+    {
+      ACE_ERROR ((LM_ERROR, "MAIN - "
+            "Cannot append profile list. RetCode %d\n",retcode));
+      return ++retval;
+    }
+  }
+  return retval;
+}
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/qos_dumpMemBuf.mpc b/tests/DCPS/QoS_XML/dumpMemBuf/qos_dumpMemBuf.mpc
new file mode 100644
index 000000000..a098ce2d6
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/qos_dumpMemBuf.mpc
@@ -0,0 +1,9 @@
+
+project : taoexe, dcps_qos_xml_handler {
+  exename   = qos_dumpMemBufTest
+
+  Source_Files {
+    qos_dumpMemBuf.cpp
+  }
+}
+
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/run_test.pl b/tests/DCPS/QoS_XML/dumpMemBuf/run_test.pl
new file mode 100755
index 000000000..88953b798
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/run_test.pl
@@ -0,0 +1,20 @@
+eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
+     & eval 'exec perl -S $0 $argv:q'
+     if 0;
+
+# -*- perl -*-
+
+use lib "$ENV{ACE_ROOT}/bin";
+use PerlACE::TestTarget;
+
+my $program = PerlACE::TestTarget::create_target (1) || die "Create target 1 failed\n";
+
+$PROG = $program->CreateProcess ("qos_dump");
+$program_status = $PROG->SpawnWaitKill ($program->ProcessStartWaitInterval ());
+
+if ($program_status != 0) {
+    print STDERR "ERROR: qos_dump returned $program_status\n";
+    exit 1;
+}
+
+exit 0;
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/test.xml b/tests/DCPS/QoS_XML/dumpMemBuf/test.xml
new file mode 100644
index 000000000..7c3f4d7ba
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/test.xml
@@ -0,0 +1,279 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<tst:test xmlns:tst="urn:internal:test:1.0"
+          xmlns="http://www.omg.org/dds"
+          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+          xsi:schemaLocation="urn:internal:test:1.0 test.xsd">
+  <dds>
+    <qos_profile name="TestProfile">
+      <datareader_qos>
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+        <deadline>
+          <period>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </period>
+        </deadline>
+        <latency_budget>
+          <duration>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </duration>
+        </latency_budget>
+        <liveliness>
+          <kind>AUTOMATIC_LIVELINESS_QOS</kind>
+          <lease_duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </lease_duration>
+        </liveliness>
+        <reliability>
+          <kind>BEST_EFFORT_RELIABILITY_QOS</kind>
+          <max_blocking_time>
+            <sec>0</sec>
+            <nanosec>100000000</nanosec>
+          </max_blocking_time>
+        </reliability>
+        <destination_order>
+          <kind>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</kind>
+        </destination_order>
+        <history>
+          <kind>KEEP_LAST_HISTORY_QOS</kind>
+          <depth>1</depth>
+        </history>
+        <resource_limits>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </resource_limits>
+        <!--user_data>
+          <value></value>
+        </user_data-->
+        <ownership>
+          <kind>SHARED_OWNERSHIP_QOS</kind>
+        </ownership>
+        <time_based_filter>
+          <minimum_separation>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </minimum_separation>
+        </time_based_filter>
+        <reader_data_lifecycle>
+          <autopurge_nowriter_samples_delay>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </autopurge_nowriter_samples_delay>
+          <autopurge_disposed_samples_delay>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </autopurge_disposed_samples_delay>
+        </reader_data_lifecycle>
+      </datareader_qos>
+      <datawriter_qos>
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+        <durability_service>
+          <service_cleanup_delay>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </service_cleanup_delay>
+          <history_kind>KEEP_LAST_HISTORY_QOS</history_kind>
+          <history_depth>1</history_depth>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </durability_service>
+        <deadline>
+          <period>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </period>
+        </deadline>
+        <latency_budget>
+          <duration>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </duration>
+        </latency_budget>
+        <liveliness>
+          <kind>AUTOMATIC_LIVELINESS_QOS</kind>
+          <lease_duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </lease_duration>
+        </liveliness>
+        <reliability>
+          <kind>RELIABLE_RELIABILITY_QOS</kind>
+          <max_blocking_time>
+            <sec>0</sec>
+            <nanosec>100000000</nanosec>
+          </max_blocking_time>
+        </reliability>
+        <destination_order>
+          <kind>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</kind>
+        </destination_order>
+        <history>
+          <kind>KEEP_ALL_HISTORY_QOS</kind>
+          <depth>5</depth>
+        </history>
+        <resource_limits>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </resource_limits>
+        <transport_priority>
+          <value>0</value>
+        </transport_priority>
+        <lifespan>
+          <duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </duration>
+        </lifespan>
+        <!--user_data>
+          <value></value>
+        </user_data-->
+        <ownership>
+          <kind>SHARED_OWNERSHIP_QOS</kind>
+        </ownership>
+        <ownership_strength>
+          <value>0</value>
+        </ownership_strength>
+        <writer_data_lifecycle>
+          <autodispose_unregistered_instances>true</autodispose_unregistered_instances>
+        </writer_data_lifecycle>
+      </datawriter_qos>
+      <domainparticipant_qos>
+        <!--user_data>
+          <value></value>
+        </user_data-->
+        <entity_factory>
+          <autoenable_created_entities>true</autoenable_created_entities>
+        </entity_factory>
+      </domainparticipant_qos>
+      <subscriber_qos>
+        <presentation>
+          <access_scope>INSTANCE_PRESENTATION_QOS</access_scope>
+          <coherent_access>false</coherent_access>
+          <ordered_access>false</ordered_access>
+        </presentation>
+        <partition>
+          <name>
+            <element>ABC</element>
+            <element>DEF</element>
+            <element>GHI</element>
+            <element>JKL</element>
+            <element>MNO</element>
+            <element>PQR</element>
+            <element>STU</element>
+            <element>VW</element>
+            <element>XYZ</element>
+          </name>
+        </partition>
+        <!--group_data>
+          <value></value>
+        </group_data-->
+        <entity_factory>
+          <autoenable_created_entities>true</autoenable_created_entities>
+        </entity_factory>
+      </subscriber_qos>
+      <publisher_qos>
+        <presentation>
+          <access_scope>INSTANCE_PRESENTATION_QOS</access_scope>
+          <coherent_access>false</coherent_access>
+          <ordered_access>false</ordered_access>
+        </presentation>
+        <partition>
+          <name>
+            <element>XYZ</element>
+            <element>VW</element>
+            <element>STU</element>
+            <element>PQR</element>
+            <element>MNO</element>
+            <element>JKL</element>
+            <element>GHI</element>
+            <element>DEF</element>
+            <element>ABC</element>
+          </name>
+        </partition>
+        <!--group_data>
+          <value></value>
+        </group_data-->
+        <entity_factory>
+          <autoenable_created_entities>true</autoenable_created_entities>
+        </entity_factory>
+      </publisher_qos>
+      <topic_qos>
+        <!--topic_data>
+          <value></value>
+        </topic_data-->
+        <durability>
+          <kind>VOLATILE_DURABILITY_QOS</kind>
+        </durability>
+        <durability_service>
+          <service_cleanup_delay>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </service_cleanup_delay>
+          <history_kind>KEEP_LAST_HISTORY_QOS</history_kind>
+          <history_depth>1</history_depth>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </durability_service>
+        <deadline>
+          <period>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </period>
+        </deadline>
+        <latency_budget>
+          <duration>
+            <sec>0</sec>
+            <nanosec>0</nanosec>
+          </duration>
+        </latency_budget>
+        <liveliness>
+          <kind>AUTOMATIC_LIVELINESS_QOS</kind>
+          <lease_duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </lease_duration>
+        </liveliness>
+        <reliability>
+          <kind>BEST_EFFORT_RELIABILITY_QOS</kind>
+          <max_blocking_time>
+            <sec>0</sec>
+            <nanosec>100000000</nanosec>
+          </max_blocking_time>
+        </reliability>
+        <destination_order>
+          <kind>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</kind>
+        </destination_order>
+        <history>
+          <kind>KEEP_LAST_HISTORY_QOS</kind>
+          <depth>1</depth>
+        </history>
+        <resource_limits>
+          <max_samples>LENGTH_UNLIMITED</max_samples>
+          <max_instances>LENGTH_UNLIMITED</max_instances>
+          <max_samples_per_instance>LENGTH_UNLIMITED</max_samples_per_instance>
+        </resource_limits>
+        <transport_priority>
+          <value>0</value>
+        </transport_priority>
+        <lifespan>
+          <duration>
+            <sec>DURATION_INFINITE_SEC</sec>
+            <nanosec>DURATION_INFINITE_NSEC</nanosec>
+          </duration>
+        </lifespan>
+        <ownership>
+          <kind>SHARED_OWNERSHIP_QOS</kind>
+        </ownership>
+      </topic_qos>
+    </qos_profile>
+  </dds>
+</tst:test>
diff --git a/tests/DCPS/QoS_XML/dumpMemBuf/test.xsd b/tests/DCPS/QoS_XML/dumpMemBuf/test.xsd
new file mode 100644
index 000000000..ba7a94240
--- /dev/null
+++ b/tests/DCPS/QoS_XML/dumpMemBuf/test.xsd
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xs:schema
+  targetNamespace="urn:internal:test:1.0"
+  elementFormDefault="qualified"
+  xmlns:opendds="http://www.omg.org/dds"
+  xmlns:xs="http://www.w3.org/2001/XMLSchema"
+  xmlns="urn:internal:test:1.0">
+
+  <xs:import namespace="http://www.omg.org/dds" schemaLocation="dds_qos.xsd"></xs:import>
+
+  <xs:complexType name="testType">
+    <xs:sequence minOccurs="1">
+      <xs:element ref="opendds:dds"></xs:element>
+    </xs:sequence>
+  </xs:complexType>
+
+  <xs:element name="test" type="testType"></xs:element>
+
+</xs:schema>
